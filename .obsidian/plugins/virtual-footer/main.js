/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  MultiSuggest: () => MultiSuggest,
  default: () => VirtualFooterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var RuleType = /* @__PURE__ */ ((RuleType2) => {
  RuleType2["Folder"] = "folder";
  RuleType2["Tag"] = "tag";
  RuleType2["Property"] = "property";
  return RuleType2;
})(RuleType || {});
var ContentSource = /* @__PURE__ */ ((ContentSource2) => {
  ContentSource2["Text"] = "text";
  ContentSource2["File"] = "file";
  return ContentSource2;
})(ContentSource || {});
var DEFAULT_SETTINGS = {
  rules: [{
    name: "Default Rule",
    enabled: true,
    type: "folder" /* Folder */,
    path: "",
    // Matches all files by default
    recursive: true,
    contentSource: "text" /* Text */,
    footerText: "",
    // Default content is empty
    renderLocation: "footer" /* Footer */
  }]
};
var CSS_DYNAMIC_CONTENT_ELEMENT = "virtual-footer-dynamic-content-element";
var CSS_HEADER_GROUP_ELEMENT = "virtual-footer-header-group";
var CSS_FOOTER_GROUP_ELEMENT = "virtual-footer-footer-group";
var CSS_HEADER_RENDERED_CONTENT = "virtual-footer-header-rendered-content";
var CSS_FOOTER_RENDERED_CONTENT = "virtual-footer-footer-rendered-content";
var CSS_VIRTUAL_FOOTER_CM_PADDING = "virtual-footer-cm-padding";
var CSS_VIRTUAL_FOOTER_REMOVE_FLEX = "virtual-footer-remove-flex";
var SELECTOR_EDITOR_CONTENT_AREA = ".cm-editor .cm-content";
var SELECTOR_EDITOR_CONTENT_CONTAINER_PARENT = ".markdown-source-view.mod-cm6 .cm-contentContainer";
var SELECTOR_LIVE_PREVIEW_CONTENT_CONTAINER = ".cm-contentContainer";
var SELECTOR_EDITOR_SIZER = ".cm-sizer";
var SELECTOR_PREVIEW_HEADER_AREA = ".mod-header.mod-ui";
var SELECTOR_PREVIEW_FOOTER_AREA = ".mod-footer";
var MultiSuggest = class extends import_obsidian.AbstractInputSuggest {
  /**
   * Creates an instance of MultiSuggest.
   * @param inputEl The HTML input element to attach the suggester to.
   * @param content The set of strings to use as suggestions.
   * @param onSelectCb Callback function executed when a suggestion is selected.
   * @param app The Obsidian App instance.
   */
  constructor(inputEl, content, onSelectCb, app) {
    super(app, inputEl);
    this.inputEl = inputEl;
    this.content = content;
    this.onSelectCb = onSelectCb;
  }
  /**
   * Filters the content set to find suggestions matching the input string.
   * @param inputStr The current string in the input field.
   * @returns An array of matching suggestion strings.
   */
  getSuggestions(inputStr) {
    const lowerCaseInputStr = inputStr.toLocaleLowerCase();
    return [...this.content].filter(
      (contentItem) => contentItem.toLocaleLowerCase().includes(lowerCaseInputStr)
    );
  }
  /**
   * Renders a single suggestion item in the suggestion list.
   * @param content The suggestion string to render.
   * @param el The HTMLElement to render the suggestion into.
   */
  renderSuggestion(content, el) {
    el.setText(content);
  }
  /**
   * Handles the selection of a suggestion.
   * @param content The selected suggestion string.
   * @param _evt The mouse or keyboard event that triggered the selection.
   */
  selectSuggestion(content, _evt) {
    this.onSelectCb(content);
    this.inputEl.value = content;
    this.inputEl.blur();
    this.close();
  }
};
var VirtualFooterPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    /** Stores pending content injections for preview mode, awaiting DOM availability. */
    this.pendingPreviewInjections = /* @__PURE__ */ new WeakMap();
    /** Manages MutationObservers for views in preview mode to detect when injection targets are ready. */
    this.previewObservers = /* @__PURE__ */ new WeakMap();
    this.initialLayoutReadyProcessed = false;
    /**
     * Handles changes to the active Markdown view, triggering content processing.
     */
    this.handleActiveViewChange = () => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      this._processView(activeView);
    };
  }
  /**
   * Called when the plugin is loaded.
   */
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new VirtualFooterSettingTab(this.app, this));
    const guardedHandleActiveViewChange = () => {
      if (this.initialLayoutReadyProcessed) {
        this.handleActiveViewChange();
      }
    };
    this.registerEvent(
      this.app.workspace.on("file-open", guardedHandleActiveViewChange)
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", guardedHandleActiveViewChange)
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        if (this.initialLayoutReadyProcessed) {
          const activeFile = this.app.workspace.getActiveFile();
          if (activeFile && activeFile.path === file.path) {
            this.handleActiveViewChange();
          }
        }
      })
    );
    this.app.workspace.onLayoutReady(() => {
      if (!this.initialLayoutReadyProcessed) {
        this.handleActiveViewChange();
        this.initialLayoutReadyProcessed = true;
      }
    });
  }
  /**
   * Called when the plugin is unloaded.
   * Cleans up all injected content and observers.
   */
  async onunload() {
    this.clearAllViewsDynamicContent();
    document.querySelectorAll(`.${CSS_DYNAMIC_CONTENT_ELEMENT}`).forEach((el) => {
      const componentHolder = el;
      if (componentHolder.component) {
        componentHolder.component.unload();
      }
      el.remove();
    });
    document.querySelectorAll(`.${CSS_VIRTUAL_FOOTER_CM_PADDING}`).forEach((el) => el.classList.remove(CSS_VIRTUAL_FOOTER_CM_PADDING));
    document.querySelectorAll(`.${CSS_VIRTUAL_FOOTER_REMOVE_FLEX}`).forEach((el) => el.classList.remove(CSS_VIRTUAL_FOOTER_REMOVE_FLEX));
    this.previewObservers = /* @__PURE__ */ new WeakMap();
    this.pendingPreviewInjections = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Processes a given Markdown view to inject or update dynamic content.
   * @param view The MarkdownView to process.
   */
  async _processView(view) {
    if (!view || !view.file) {
      return;
    }
    await this.removeDynamicContentFromView(view);
    const applicableRulesWithContent = await this._getApplicableRulesAndContent(view.file.path);
    if (applicableRulesWithContent.length === 0) {
      return;
    }
    const viewState = view.getState();
    let combinedHeaderText = "";
    let combinedFooterText = "";
    let hasFooterRule = false;
    const contentSeparator = "\n\n";
    for (const { rule, contentText } of applicableRulesWithContent) {
      if (!contentText || contentText.trim() === "")
        continue;
      if (rule.renderLocation === "header" /* Header */) {
        combinedHeaderText += (combinedHeaderText ? contentSeparator : "") + contentText;
      } else {
        combinedFooterText += (combinedFooterText ? contentSeparator : "") + contentText;
        hasFooterRule = true;
      }
    }
    if (viewState.mode === "source" && !viewState.source && hasFooterRule) {
      this.applyLivePreviewFooterStyles(view);
    }
    let pendingHeaderDiv = null;
    let pendingFooterDiv = null;
    if (viewState.mode === "preview" || viewState.mode === "source" && !viewState.source) {
      if (combinedHeaderText.trim()) {
        const result = await this.renderAndInjectGroupedContent(view, combinedHeaderText, "header" /* Header */);
        if (result && viewState.mode === "preview") {
          pendingHeaderDiv = result;
        }
      }
      if (combinedFooterText.trim()) {
        const result = await this.renderAndInjectGroupedContent(view, combinedFooterText, "footer" /* Footer */);
        if (result && viewState.mode === "preview") {
          pendingFooterDiv = result;
        }
      }
    }
    if (pendingHeaderDiv || pendingFooterDiv) {
      let pending = this.pendingPreviewInjections.get(view);
      if (!pending) {
        pending = {};
        this.pendingPreviewInjections.set(view, pending);
      }
      if (pendingHeaderDiv)
        pending.headerDiv = pendingHeaderDiv;
      if (pendingFooterDiv)
        pending.footerDiv = pendingFooterDiv;
      this.ensurePreviewObserver(view);
    }
  }
  /**
   * Renders combined Markdown content and injects it into the specified location in the view.
   * @param view The MarkdownView to inject content into.
   * @param combinedContentText The combined Markdown string to render.
   * @param renderLocation Specifies whether to render in the header or footer.
   * @returns The rendered HTMLElement if injection is deferred (for preview mode), otherwise null.
   */
  async renderAndInjectGroupedContent(view, combinedContentText, renderLocation) {
    var _a;
    if (!combinedContentText || combinedContentText.trim() === "") {
      return null;
    }
    const isRenderInHeader = renderLocation === "header" /* Header */;
    const sourcePath = ((_a = view.file) == null ? void 0 : _a.path) || "";
    const groupDiv = document.createElement("div");
    groupDiv.className = CSS_DYNAMIC_CONTENT_ELEMENT;
    groupDiv.classList.add(
      isRenderInHeader ? CSS_HEADER_GROUP_ELEMENT : CSS_FOOTER_GROUP_ELEMENT,
      isRenderInHeader ? CSS_HEADER_RENDERED_CONTENT : CSS_FOOTER_RENDERED_CONTENT
    );
    const component = new import_obsidian.Component();
    component.load();
    groupDiv.component = component;
    await import_obsidian.MarkdownRenderer.render(this.app, combinedContentText, groupDiv, sourcePath, component);
    let injectionSuccessful = false;
    const viewState = view.getState();
    if (viewState.mode === "preview") {
      const previewContentParent = view.previewMode.containerEl;
      const targetParent = previewContentParent.querySelector(
        isRenderInHeader ? SELECTOR_PREVIEW_HEADER_AREA : SELECTOR_PREVIEW_FOOTER_AREA
      );
      if (targetParent) {
        targetParent.appendChild(groupDiv);
        injectionSuccessful = true;
      }
    } else if (viewState.mode === "source" && !viewState.source) {
      if (isRenderInHeader) {
        const cmContentContainer = view.containerEl.querySelector(SELECTOR_LIVE_PREVIEW_CONTENT_CONTAINER);
        if (cmContentContainer == null ? void 0 : cmContentContainer.parentElement) {
          cmContentContainer.parentElement.insertBefore(groupDiv, cmContentContainer);
          injectionSuccessful = true;
        }
      } else {
        const targetParent = view.containerEl.querySelector(SELECTOR_EDITOR_SIZER);
        if (targetParent) {
          targetParent.appendChild(groupDiv);
          injectionSuccessful = true;
        }
      }
    }
    if (injectionSuccessful) {
      this.attachInternalLinkHandlers(groupDiv, sourcePath, component);
      return null;
    } else {
      if (viewState.mode === "preview") {
        console.log(`VirtualFooter: Deferring injection for ${renderLocation} in preview mode. Target not found yet.`);
        return groupDiv;
      } else {
        component.unload();
        console.warn(`VirtualFooter: Failed to find injection point for dynamic content group (${renderLocation}). View mode: ${viewState.mode}.`);
        return null;
      }
    }
  }
  /**
   * Ensures a MutationObserver is set up for a view in preview mode to handle deferred content injection.
   * The observer watches for the appearance of target DOM elements.
   * @param view The MarkdownView to observe.
   */
  ensurePreviewObserver(view) {
    var _a;
    if (this.previewObservers.has(view) || !view.file || !((_a = view.previewMode) == null ? void 0 : _a.containerEl)) {
      return;
    }
    const observer = new MutationObserver((_mutations) => {
      var _a2, _b, _c, _d;
      if (!view.file) {
        observer.disconnect();
        this.previewObservers.delete(view);
        const pendingStale = this.pendingPreviewInjections.get(view);
        if (pendingStale) {
          (_b = (_a2 = pendingStale.headerDiv) == null ? void 0 : _a2.component) == null ? void 0 : _b.unload();
          (_d = (_c = pendingStale.footerDiv) == null ? void 0 : _c.component) == null ? void 0 : _d.unload();
          this.pendingPreviewInjections.delete(view);
        }
        return;
      }
      const pending = this.pendingPreviewInjections.get(view);
      if (!pending || !pending.headerDiv && !pending.footerDiv) {
        observer.disconnect();
        this.previewObservers.delete(view);
        if (pending)
          this.pendingPreviewInjections.delete(view);
        return;
      }
      let allResolved = true;
      const sourcePath = view.file.path;
      if (pending.headerDiv) {
        const headerTargetParent = view.previewMode.containerEl.querySelector(SELECTOR_PREVIEW_HEADER_AREA);
        if (headerTargetParent) {
          headerTargetParent.appendChild(pending.headerDiv);
          if (pending.headerDiv.component) {
            this.attachInternalLinkHandlers(pending.headerDiv, sourcePath, pending.headerDiv.component);
          }
          delete pending.headerDiv;
        } else {
          allResolved = false;
        }
      }
      if (pending.footerDiv) {
        const footerTargetParent = view.previewMode.containerEl.querySelector(SELECTOR_PREVIEW_FOOTER_AREA);
        if (footerTargetParent) {
          footerTargetParent.appendChild(pending.footerDiv);
          if (pending.footerDiv.component) {
            this.attachInternalLinkHandlers(pending.footerDiv, sourcePath, pending.footerDiv.component);
          }
          delete pending.footerDiv;
        } else {
          allResolved = false;
        }
      }
      if (allResolved) {
        observer.disconnect();
        this.previewObservers.delete(view);
        this.pendingPreviewInjections.delete(view);
      }
    });
    observer.observe(view.previewMode.containerEl, { childList: true, subtree: true });
    this.previewObservers.set(view, observer);
  }
  /**
   * Applies CSS classes to adjust CodeMirror (Live Preview) layout for footer content.
   * @param view The MarkdownView in Live Preview mode.
   */
  applyLivePreviewFooterStyles(view) {
    const contentEl = view.containerEl.querySelector(SELECTOR_EDITOR_CONTENT_AREA);
    const containerEl = view.containerEl.querySelector(SELECTOR_EDITOR_CONTENT_CONTAINER_PARENT);
    contentEl == null ? void 0 : contentEl.classList.add(CSS_VIRTUAL_FOOTER_CM_PADDING);
    containerEl == null ? void 0 : containerEl.classList.add(CSS_VIRTUAL_FOOTER_REMOVE_FLEX);
  }
  /**
   * Removes CSS classes used for Live Preview footer layout adjustments.
   * @param viewOrContainer The MarkdownView or a specific HTMLElement container.
   */
  removeLivePreviewFooterStyles(viewOrContainer) {
    const container = viewOrContainer instanceof import_obsidian.MarkdownView ? viewOrContainer.containerEl : viewOrContainer;
    const contentEl = container.querySelector(SELECTOR_EDITOR_CONTENT_AREA);
    const containerEl = container.querySelector(SELECTOR_EDITOR_CONTENT_CONTAINER_PARENT);
    contentEl == null ? void 0 : contentEl.classList.remove(CSS_VIRTUAL_FOOTER_CM_PADDING);
    containerEl == null ? void 0 : containerEl.classList.remove(CSS_VIRTUAL_FOOTER_REMOVE_FLEX);
  }
  /**
   * Removes all plugin-injected DOM elements from a given container.
   * @param containerEl The HTMLElement to search within.
   */
  async removeInjectedContentDOM(containerEl) {
    containerEl.querySelectorAll(`.${CSS_DYNAMIC_CONTENT_ELEMENT}`).forEach((el) => {
      const componentHolder = el;
      if (componentHolder.component) {
        componentHolder.component.unload();
      }
      el.remove();
    });
  }
  /**
   * Removes all dynamic content, styles, and observers associated with a specific view.
   * @param view The MarkdownView to clean up.
   */
  async removeDynamicContentFromView(view) {
    var _a, _b, _c, _d;
    this.removeLivePreviewFooterStyles(view);
    await this.removeInjectedContentDOM(view.containerEl);
    const observer = this.previewObservers.get(view);
    if (observer) {
      observer.disconnect();
      this.previewObservers.delete(view);
    }
    const pending = this.pendingPreviewInjections.get(view);
    if (pending) {
      (_b = (_a = pending.headerDiv) == null ? void 0 : _a.component) == null ? void 0 : _b.unload();
      (_d = (_c = pending.footerDiv) == null ? void 0 : _c.component) == null ? void 0 : _d.unload();
      this.pendingPreviewInjections.delete(view);
    }
  }
  /**
   * Clears dynamic content from all currently open Markdown views.
   * Typically used during plugin unload or when global settings change significantly.
   */
  clearAllViewsDynamicContent() {
    this.app.workspace.getLeavesOfType("markdown").forEach((leaf) => {
      if (leaf.view instanceof import_obsidian.MarkdownView) {
        this.removeDynamicContentFromView(leaf.view);
      }
    });
  }
  /**
   * Determines which rules apply to a given file path and fetches their content.
   * @param filePath The path of the file to check against rules.
   * @returns A promise that resolves to an array of objects, each containing an applicable rule and its content.
   */
  async _getApplicableRulesAndContent(filePath) {
    var _a, _b, _c, _d;
    const allApplicable = [];
    const abstractFile = this.app.vault.getAbstractFileByPath(filePath);
    if (!(abstractFile instanceof import_obsidian.TFile)) {
      return [];
    }
    const file = abstractFile;
    let fileTags = null;
    const fileCache = this.app.metadataCache.getFileCache(file);
    const hasEnabledTagRule = this.settings.rules.some((r) => r.enabled && r.type === "tag" /* Tag */);
    if (hasEnabledTagRule && fileCache) {
      const allTagsInFileWithHash = (0, import_obsidian.getAllTags)(fileCache);
      fileTags = allTagsInFileWithHash ? allTagsInFileWithHash.map((tag) => tag.substring(1)) : [];
    }
    for (const currentRule of this.settings.rules) {
      if (!currentRule.enabled) {
        continue;
      }
      let isMatch = false;
      const ruleRecursive = currentRule.recursive === void 0 ? true : currentRule.recursive;
      if (currentRule.type === "folder" /* Folder */ && currentRule.path !== void 0) {
        if (currentRule.path === "") {
          isMatch = true;
        } else if (currentRule.path === "/") {
          isMatch = ruleRecursive ? true : (_b = (_a = file.parent) == null ? void 0 : _a.isRoot()) != null ? _b : false;
        } else {
          let normalizedRuleFolderPath = currentRule.path.endsWith("/") ? currentRule.path.slice(0, -1) : currentRule.path;
          if (ruleRecursive) {
            isMatch = file.path.startsWith(normalizedRuleFolderPath + "/");
          } else {
            isMatch = ((_c = file.parent) == null ? void 0 : _c.path) === normalizedRuleFolderPath;
          }
        }
      } else if (currentRule.type === "tag" /* Tag */ && currentRule.tag && fileTags) {
        const ruleTag = currentRule.tag;
        const includeSubtags = (_d = currentRule.includeSubtags) != null ? _d : false;
        for (const fileTag of fileTags) {
          if (includeSubtags) {
            if (fileTag === ruleTag || fileTag.startsWith(ruleTag + "/")) {
              isMatch = true;
              break;
            }
          } else {
            if (fileTag === ruleTag) {
              isMatch = true;
              break;
            }
          }
        }
      } else if (currentRule.type === "property" /* Property */ && currentRule.propertyName && (fileCache == null ? void 0 : fileCache.frontmatter)) {
        const propertyKey = currentRule.propertyName;
        const expectedPropertyValue = currentRule.propertyValue;
        const actualPropertyValue = fileCache.frontmatter[propertyKey];
        if (actualPropertyValue !== void 0 && actualPropertyValue !== null) {
          if (typeof actualPropertyValue === "string") {
            isMatch = actualPropertyValue === expectedPropertyValue;
          } else if (Array.isArray(actualPropertyValue)) {
            isMatch = actualPropertyValue.map(String).includes(expectedPropertyValue);
          } else if (typeof actualPropertyValue === "number" || typeof actualPropertyValue === "boolean") {
            isMatch = String(actualPropertyValue) === expectedPropertyValue;
          }
        }
      }
      if (isMatch) {
        const contentText = await this._fetchContentForRule(currentRule);
        allApplicable.push({ rule: currentRule, contentText });
      }
    }
    return allApplicable;
  }
  /**
   * Fetches the content for a given rule, either from direct text or from a specified file.
   * @param rule The rule for which to fetch content.
   * @returns A promise that resolves to the content string.
   */
  async _fetchContentForRule(rule) {
    if (rule.contentSource === "file" /* File */ && rule.footerFilePath) {
      const file = this.app.vault.getAbstractFileByPath(rule.footerFilePath);
      if (file instanceof import_obsidian.TFile) {
        try {
          return await this.app.vault.cachedRead(file);
        } catch (error) {
          console.error(`VirtualFooter: Error reading content file ${rule.footerFilePath}`, error);
          return `<!-- Error reading content file: ${rule.footerFilePath} -->`;
        }
      } else {
        console.warn(`VirtualFooter: Content file not found for rule: ${rule.footerFilePath}`);
        return `<!-- Content file not found: ${rule.footerFilePath} -->`;
      }
    }
    return rule.footerText || "";
  }
  /**
   * Attaches event handlers to the injected content for internal link navigation.
   * @param container The HTMLElement containing the rendered Markdown.
   * @param sourcePath The path of the file where the content is injected, for link resolution.
   * @param component The Obsidian Component associated with this content, for event registration.
   */
  attachInternalLinkHandlers(container, sourcePath, component) {
    component.registerDomEvent(container, "click", (event) => {
      if (event.button !== 0)
        return;
      const target = event.target;
      const linkElement = target.closest("a.internal-link");
      if (linkElement) {
        event.preventDefault();
        const href = linkElement.dataset.href;
        if (href) {
          const inNewPane = event.ctrlKey || event.metaKey;
          this.app.workspace.openLinkText(href, sourcePath, inNewPane);
        }
      }
    });
    component.registerDomEvent(container, "auxclick", (event) => {
      if (event.button !== 1)
        return;
      const target = event.target;
      const linkElement = target.closest("a.internal-link");
      if (linkElement) {
        event.preventDefault();
        const href = linkElement.dataset.href;
        if (href) {
          this.app.workspace.openLinkText(href, sourcePath, true);
        }
      }
    });
  }
  /**
   * Loads plugin settings from storage, migrating old formats if necessary.
   */
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
    if (loadedData) {
      const oldGlobalRenderLocation = loadedData.renderLocation;
      if (loadedData.rules && Array.isArray(loadedData.rules)) {
        this.settings.rules = loadedData.rules.map(
          (loadedRule) => this._migrateRule(loadedRule, oldGlobalRenderLocation)
        );
      }
    }
    if (!this.settings.rules || this.settings.rules.length === 0) {
      this.settings.rules = [JSON.parse(JSON.stringify(DEFAULT_SETTINGS.rules[0]))];
      this.normalizeRule(this.settings.rules[0]);
    } else {
      this.settings.rules.forEach((rule) => this.normalizeRule(rule));
    }
  }
  /**
   * Migrates a rule from an older settings format to the current Rule interface.
   * @param loadedRule The rule object loaded from storage.
   * @param globalRenderLocation An optional global render location from a very old settings format.
   * @returns A migrated and normalized Rule object.
   */
  _migrateRule(loadedRule, globalRenderLocation) {
    let type;
    if (Object.values(RuleType).includes(loadedRule.type)) {
      type = loadedRule.type;
    } else if (typeof loadedRule.folderPath === "string") {
      type = "folder" /* Folder */;
    } else {
      type = DEFAULT_SETTINGS.rules[0].type;
    }
    let contentSource;
    if (Object.values(ContentSource).includes(loadedRule.contentSource)) {
      contentSource = loadedRule.contentSource;
    } else {
      contentSource = typeof loadedRule.folderPath === "string" && loadedRule.contentSource === void 0 ? "text" /* Text */ : DEFAULT_SETTINGS.rules[0].contentSource;
    }
    const migratedRule = {
      name: loadedRule.name || DEFAULT_SETTINGS.rules[0].name,
      enabled: loadedRule.enabled !== void 0 ? loadedRule.enabled : DEFAULT_SETTINGS.rules[0].enabled,
      type,
      contentSource,
      footerText: loadedRule.footerText || "",
      // Retain name for compatibility
      renderLocation: loadedRule.renderLocation || globalRenderLocation || DEFAULT_SETTINGS.rules[0].renderLocation,
      recursive: loadedRule.recursive !== void 0 ? loadedRule.recursive : true
    };
    if (migratedRule.type === "folder" /* Folder */) {
      migratedRule.path = loadedRule.path !== void 0 ? loadedRule.path : loadedRule.folderPath !== void 0 ? loadedRule.folderPath : DEFAULT_SETTINGS.rules[0].path;
    } else if (migratedRule.type === "tag" /* Tag */) {
      migratedRule.tag = loadedRule.tag !== void 0 ? loadedRule.tag : "";
      migratedRule.includeSubtags = loadedRule.includeSubtags !== void 0 ? loadedRule.includeSubtags : false;
    } else if (migratedRule.type === "property" /* Property */) {
      migratedRule.propertyName = loadedRule.propertyName || "";
      migratedRule.propertyValue = loadedRule.propertyValue || "";
    }
    if (migratedRule.contentSource === "file" /* File */) {
      migratedRule.footerFilePath = loadedRule.footerFilePath || "";
    }
    return migratedRule;
  }
  /**
   * Normalizes a rule object, ensuring all required fields are present and defaults are applied.
   * Also cleans up fields that are not relevant to the rule's current type or content source.
   * @param rule The rule to normalize.
   */
  normalizeRule(rule) {
    rule.name = rule.name === void 0 ? DEFAULT_SETTINGS.rules[0].name : rule.name;
    rule.enabled = typeof rule.enabled === "boolean" ? rule.enabled : DEFAULT_SETTINGS.rules[0].enabled;
    rule.type = rule.type || DEFAULT_SETTINGS.rules[0].type;
    if (rule.type === "folder" /* Folder */) {
      rule.path = rule.path === void 0 ? DEFAULT_SETTINGS.rules[0].path || "" : rule.path;
      rule.recursive = rule.path === "" ? true : typeof rule.recursive === "boolean" ? rule.recursive : true;
      delete rule.tag;
      delete rule.includeSubtags;
      delete rule.propertyName;
      delete rule.propertyValue;
    } else if (rule.type === "tag" /* Tag */) {
      rule.tag = rule.tag === void 0 ? "" : rule.tag;
      rule.includeSubtags = typeof rule.includeSubtags === "boolean" ? rule.includeSubtags : false;
      delete rule.path;
      delete rule.recursive;
      delete rule.propertyName;
      delete rule.propertyValue;
    } else if (rule.type === "property" /* Property */) {
      rule.propertyName = rule.propertyName === void 0 ? "" : rule.propertyName;
      rule.propertyValue = rule.propertyValue === void 0 ? "" : rule.propertyValue;
      delete rule.path;
      delete rule.recursive;
      delete rule.tag;
      delete rule.includeSubtags;
    }
    rule.contentSource = rule.contentSource || DEFAULT_SETTINGS.rules[0].contentSource;
    rule.footerText = rule.footerText || "";
    rule.renderLocation = rule.renderLocation || DEFAULT_SETTINGS.rules[0].renderLocation;
    if (rule.contentSource === "file" /* File */) {
      rule.footerFilePath = rule.footerFilePath || "";
    } else {
      delete rule.footerFilePath;
    }
  }
  /**
   * Saves the current plugin settings to storage and triggers a view refresh.
   */
  async saveSettings() {
    this.settings.rules.forEach((rule) => this.normalizeRule(rule));
    await this.saveData(this.settings);
    this.handleActiveViewChange();
  }
};
var VirtualFooterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    // Caches for suggestion lists to improve performance
    this.allFolderPathsCache = null;
    this.allTagsCache = null;
    this.allMarkdownFilePathsCache = null;
    this.allPropertyNamesCache = null;
    this.ruleExpandedStates = [];
  }
  /**
   * Lazily gets and caches all unique folder paths in the vault.
   * Includes special paths "" (all files) and "/" (root).
   * @returns A set of available folder paths.
   */
  getAvailableFolderPaths() {
    if (this.allFolderPathsCache)
      return this.allFolderPathsCache;
    const paths = /* @__PURE__ */ new Set(["/", ""]);
    this.app.vault.getAllLoadedFiles().forEach((file) => {
      if (file.parent) {
        const parentPath = file.parent.isRoot() ? "/" : file.parent.path.endsWith("/") ? file.parent.path : file.parent.path + "/";
        if (parentPath !== "/")
          paths.add(parentPath);
      }
      if ("children" in file && file.path !== "/") {
        const folderPath = file.path.endsWith("/") ? file.path : file.path + "/";
        paths.add(folderPath);
      }
    });
    this.allFolderPathsCache = paths;
    return paths;
  }
  /**
   * Lazily gets and caches all unique tags (without '#') present in Markdown files.
   * @returns A set of available tags.
   */
  getAvailableTags() {
    if (this.allTagsCache)
      return this.allTagsCache;
    const collectedTags = /* @__PURE__ */ new Set();
    this.app.vault.getMarkdownFiles().forEach((file) => {
      const fileCache = this.app.metadataCache.getFileCache(file);
      if (fileCache) {
        const tagsInFile = (0, import_obsidian.getAllTags)(fileCache);
        tagsInFile == null ? void 0 : tagsInFile.forEach((tag) => {
          collectedTags.add(tag.substring(1));
        });
      }
    });
    this.allTagsCache = collectedTags;
    return collectedTags;
  }
  /**
   * Lazily gets and caches all Markdown file paths in the vault.
   * @returns A set of available Markdown file paths.
   */
  getAvailableMarkdownFilePaths() {
    if (this.allMarkdownFilePathsCache)
      return this.allMarkdownFilePathsCache;
    const paths = /* @__PURE__ */ new Set();
    this.app.vault.getMarkdownFiles().forEach((file) => {
      paths.add(file.path);
    });
    this.allMarkdownFilePathsCache = paths;
    return paths;
  }
  /**
   * Lazily gets and caches all unique frontmatter property keys from Markdown files.
   * @returns A set of available property names.
   */
  getAvailablePropertyNames() {
    var _a, _b;
    if (this.allPropertyNamesCache)
      return this.allPropertyNamesCache;
    const keys = ((_b = (_a = this.app.metadataCache).getFrontmatterPropertyKeys) == null ? void 0 : _b.call(_a)) || [];
    this.allPropertyNamesCache = new Set(keys);
    return this.allPropertyNamesCache;
  }
  /**
   * Renders the settings tab UI.
   * This method is called by Obsidian when the settings tab is opened.
   */
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.allFolderPathsCache = null;
    this.allTagsCache = null;
    this.allMarkdownFilePathsCache = null;
    this.allPropertyNamesCache = null;
    const numRules = this.plugin.settings.rules.length;
    while (this.ruleExpandedStates.length < numRules) {
      this.ruleExpandedStates.push(false);
    }
    if (this.ruleExpandedStates.length > numRules) {
      this.ruleExpandedStates.length = numRules;
    }
    containerEl.createEl("h2", { text: "Virtual Content Settings" });
    containerEl.createEl("p", { text: "Define rules to dynamically add content to the header or footer of notes based on their folder, tags, or properties." });
    containerEl.createEl("h3", { text: "Rules" });
    const rulesContainer = containerEl.createDiv("rules-container virtual-footer-rules-container");
    if (!this.plugin.settings.rules) {
      this.plugin.settings.rules = [];
    }
    if (this.plugin.settings.rules.length === 0) {
      const newRule = JSON.parse(JSON.stringify(DEFAULT_SETTINGS.rules[0]));
      this.plugin.normalizeRule(newRule);
      this.plugin.settings.rules.push(newRule);
      if (this.ruleExpandedStates.length === 0) {
        this.ruleExpandedStates.push(false);
      }
    }
    this.plugin.settings.rules.forEach((rule, index) => {
      this.renderRuleControls(rule, index, rulesContainer);
    });
    new import_obsidian.Setting(containerEl).addButton((button) => button.setButtonText("Add new rule").setCta().setClass("virtual-footer-add-button").onClick(async () => {
      const newRule = JSON.parse(JSON.stringify(DEFAULT_SETTINGS.rules[0]));
      this.plugin.normalizeRule(newRule);
      this.plugin.settings.rules.push(newRule);
      this.ruleExpandedStates.push(false);
      await this.plugin.saveSettings();
      this.display();
    }));
  }
  /**
   * Renders the UI controls for a single rule within the settings tab.
   * @param rule The rule object to render controls for.
   * @param index The index of the rule in the settings array.
   * @param containerEl The parent HTMLElement to append the rule controls to.
   */
  renderRuleControls(rule, index, containerEl) {
    const ruleDiv = containerEl.createDiv("rule-item virtual-footer-rule-item");
    if (!this.ruleExpandedStates[index]) {
      ruleDiv.addClass("is-collapsed");
    }
    const ruleNameDisplay = rule.name && rule.name.trim() !== "" ? rule.name : "Unnamed Rule";
    const ruleHeadingText = `Rule ${index + 1}: ${ruleNameDisplay}`;
    const ruleHeading = ruleDiv.createEl("h4", { text: ruleHeadingText });
    ruleHeading.addClass("virtual-footer-rule-heading");
    const ruleContentContainer = ruleDiv.createDiv("virtual-footer-rule-content");
    ruleHeading.addEventListener("click", () => {
      const isNowExpanded = !ruleDiv.classList.toggle("is-collapsed");
      this.ruleExpandedStates[index] = isNowExpanded;
    });
    new import_obsidian.Setting(ruleContentContainer).setName("Rule name").setDesc('A descriptive name for this rule (e.g., "Project Notes Footer").').addText((text) => text.setPlaceholder("e.g., Blog Post Footer").setValue(rule.name || "").onChange(async (value) => {
      rule.name = value;
      const newNameDisplay = value && value.trim() !== "" ? value : "Unnamed Rule";
      ruleHeading.textContent = `Rule ${index + 1}: ${newNameDisplay}`;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(ruleContentContainer).setName("Enabled").setDesc("If disabled, this rule will not be applied.").addToggle((toggle) => toggle.setValue(rule.enabled).onChange(async (value) => {
      rule.enabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(ruleContentContainer).setName("Rule type").setDesc("Apply this rule based on folder, tag, or property.").addDropdown((dropdown) => dropdown.addOption("folder" /* Folder */, "Folder").addOption("tag" /* Tag */, "Tag").addOption("property" /* Property */, "Property").setValue(rule.type).onChange(async (value) => {
      rule.type = value;
      this.plugin.normalizeRule(rule);
      await this.plugin.saveSettings();
      this.display();
    }));
    if (rule.type === "folder" /* Folder */) {
      new import_obsidian.Setting(ruleContentContainer).setName("Folder path").setDesc('Path for the rule. Use "" for all files, "/" for root folder, or "FolderName/" for specific folders (ensure trailing slash for non-root folders).').addText((text) => {
        text.setPlaceholder("e.g., Meetings/, /, or empty for all").setValue(rule.path || "").onChange(async (value) => {
          rule.path = value;
          this.plugin.normalizeRule(rule);
          await this.plugin.saveSettings();
          this.display();
        });
        new MultiSuggest(text.inputEl, this.getAvailableFolderPaths(), (selectedPath) => {
          rule.path = selectedPath;
          this.plugin.normalizeRule(rule);
          text.setValue(selectedPath);
          this.plugin.saveSettings().then(() => this.display());
        }, this.plugin.app);
      });
      new import_obsidian.Setting(ruleContentContainer).setName("Include subfolders (recursive)").setDesc('If enabled, rule applies to files in subfolders. For "all files" (empty path), this is always true. For root path ("/"), enabling applies to all vault files, disabling applies only to files directly in the root.').addToggle((toggle) => {
        toggle.setValue(rule.recursive).onChange(async (value) => {
          rule.recursive = value;
          await this.plugin.saveSettings();
        });
        if (rule.path === "") {
          toggle.setDisabled(true);
        }
      });
    } else if (rule.type === "tag" /* Tag */) {
      new import_obsidian.Setting(ruleContentContainer).setName("Tag value").setDesc('Tag to match (without the # prefix). E.g., "project" or "status/done".').addText((text) => {
        text.setPlaceholder("e.g., important or project/alpha").setValue(rule.tag || "").onChange(async (value) => {
          rule.tag = value.startsWith("#") ? value.substring(1) : value;
          await this.plugin.saveSettings();
        });
        new MultiSuggest(text.inputEl, this.getAvailableTags(), (selectedTag) => {
          const normalizedTag = selectedTag.startsWith("#") ? selectedTag.substring(1) : selectedTag;
          rule.tag = normalizedTag;
          text.setValue(normalizedTag);
          this.plugin.saveSettings();
        }, this.plugin.app);
      });
      new import_obsidian.Setting(ruleContentContainer).setName("Include subtags").setDesc("If enabled, a rule for 'tag' will also apply to 'tag/subtag1', 'tag/subtag2/subtag3', etc. If disabled, it only applies to the exact tag.").addToggle((toggle) => {
        toggle.setValue(rule.includeSubtags).onChange(async (value) => {
          rule.includeSubtags = value;
          await this.plugin.saveSettings();
        });
      });
    } else if (rule.type === "property" /* Property */) {
      new import_obsidian.Setting(ruleContentContainer).setName("Property name").setDesc("The name of the Obsidian property (frontmatter key) to match.").addText((text) => {
        text.setPlaceholder("e.g., status, type, author").setValue(rule.propertyName || "").onChange(async (value) => {
          rule.propertyName = value;
          await this.plugin.saveSettings();
        });
        new MultiSuggest(text.inputEl, this.getAvailablePropertyNames(), (selectedName) => {
          rule.propertyName = selectedName;
          text.setValue(selectedName);
          this.plugin.saveSettings();
        }, this.plugin.app);
      });
      new import_obsidian.Setting(ruleContentContainer).setName("Property value").setDesc("The value the property should have. For list/array properties, matches if this value is one of the items.").addText((text) => text.setPlaceholder("e.g., complete, article, John Doe").setValue(rule.propertyValue || "").onChange(async (value) => {
        rule.propertyValue = value;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian.Setting(ruleContentContainer).setName("Content source").setDesc("Where to get the content from: direct text input or a separate Markdown file.").addDropdown((dropdown) => dropdown.addOption("text" /* Text */, "Direct text").addOption("file" /* File */, "Markdown file").setValue(rule.contentSource || "text" /* Text */).onChange(async (value) => {
      rule.contentSource = value;
      this.plugin.normalizeRule(rule);
      await this.plugin.saveSettings();
      this.display();
    }));
    if (rule.contentSource === "file" /* File */) {
      new import_obsidian.Setting(ruleContentContainer).setName("Content file path").setDesc('Path to the .md file to use as content (e.g., "templates/common-footer.md").').addText((text) => {
        text.setPlaceholder("e.g., templates/common-footer.md").setValue(rule.footerFilePath || "").onChange(async (value) => {
          rule.footerFilePath = value;
          await this.plugin.saveSettings();
        });
        new MultiSuggest(text.inputEl, this.getAvailableMarkdownFilePaths(), (selectedPath) => {
          rule.footerFilePath = selectedPath;
          text.setValue(selectedPath);
          this.plugin.saveSettings();
        }, this.plugin.app);
      });
    } else {
      new import_obsidian.Setting(ruleContentContainer).setName("Content text").setDesc("Markdown text to display. This will be rendered.").addTextArea((text) => text.setPlaceholder("Enter your markdown content here...\nSupports multiple lines and **Markdown** formatting.").setValue(rule.footerText || "").onChange(async (value) => {
        rule.footerText = value;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian.Setting(ruleContentContainer).setName("Render location").setDesc("Choose whether this rule renders its content in the header or footer of the note.").addDropdown((dropdown) => dropdown.addOption("footer" /* Footer */, "Footer").addOption("header" /* Header */, "Header").setValue(rule.renderLocation || "footer" /* Footer */).onChange(async (value) => {
      rule.renderLocation = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(ruleContentContainer).addButton((button) => button.setButtonText("Delete rule").setWarning().setClass("virtual-footer-delete-button").onClick(async () => {
      this.plugin.settings.rules.splice(index, 1);
      this.ruleExpandedStates.splice(index, 1);
      await this.plugin.saveSettings();
      this.display();
    }));
  }
};


/* nosourcemap */