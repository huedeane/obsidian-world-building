/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  MultiSuggest: () => MultiSuggest,
  default: () => VirtualFooterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var RuleType = /* @__PURE__ */ ((RuleType2) => {
  RuleType2["Folder"] = "folder";
  RuleType2["Tag"] = "tag";
  RuleType2["Property"] = "property";
  return RuleType2;
})(RuleType || {});
var ContentSource = /* @__PURE__ */ ((ContentSource2) => {
  ContentSource2["Text"] = "text";
  ContentSource2["File"] = "file";
  return ContentSource2;
})(ContentSource || {});
var DEFAULT_SETTINGS = {
  rules: [{
    name: "Default Rule",
    enabled: true,
    type: "folder" /* Folder */,
    path: "",
    // Matches all files by default
    recursive: true,
    contentSource: "text" /* Text */,
    footerText: "",
    // Default content is empty
    renderLocation: "footer" /* Footer */
  }],
  refreshOnFileOpen: false
  // Default to false
};
var CSS_DYNAMIC_CONTENT_ELEMENT = "virtual-footer-dynamic-content-element";
var CSS_HEADER_GROUP_ELEMENT = "virtual-footer-header-group";
var CSS_FOOTER_GROUP_ELEMENT = "virtual-footer-footer-group";
var CSS_HEADER_RENDERED_CONTENT = "virtual-footer-header-rendered-content";
var CSS_FOOTER_RENDERED_CONTENT = "virtual-footer-footer-rendered-content";
var CSS_VIRTUAL_FOOTER_CM_PADDING = "virtual-footer-cm-padding";
var CSS_VIRTUAL_FOOTER_REMOVE_FLEX = "virtual-footer-remove-flex";
var SELECTOR_EDITOR_CONTENT_AREA = ".cm-editor .cm-content";
var SELECTOR_EDITOR_CONTENT_CONTAINER_PARENT = ".markdown-source-view.mod-cm6 .cm-contentContainer";
var SELECTOR_LIVE_PREVIEW_CONTENT_CONTAINER = ".cm-contentContainer";
var SELECTOR_EDITOR_SIZER = ".cm-sizer";
var SELECTOR_PREVIEW_HEADER_AREA = ".mod-header.mod-ui";
var SELECTOR_PREVIEW_FOOTER_AREA = ".mod-footer";
var MultiSuggest = class extends import_obsidian.AbstractInputSuggest {
  /**
   * Creates an instance of MultiSuggest.
   * @param inputEl The HTML input element to attach the suggester to.
   * @param content The set of strings to use as suggestions.
   * @param onSelectCb Callback function executed when a suggestion is selected.
   * @param app The Obsidian App instance.
   */
  constructor(inputEl, content, onSelectCb, app) {
    super(app, inputEl);
    this.inputEl = inputEl;
    this.content = content;
    this.onSelectCb = onSelectCb;
  }
  /**
   * Filters the content set to find suggestions matching the input string.
   * @param inputStr The current string in the input field.
   * @returns An array of matching suggestion strings.
   */
  getSuggestions(inputStr) {
    const lowerCaseInputStr = inputStr.toLocaleLowerCase();
    return [...this.content].filter(
      (contentItem) => contentItem.toLocaleLowerCase().includes(lowerCaseInputStr)
    );
  }
  /**
   * Renders a single suggestion item in the suggestion list.
   * @param content The suggestion string to render.
   * @param el The HTMLElement to render the suggestion into.
   */
  renderSuggestion(content, el) {
    el.setText(content);
  }
  /**
   * Handles the selection of a suggestion.
   * @param content The selected suggestion string.
   * @param _evt The mouse or keyboard event that triggered the selection.
   */
  selectSuggestion(content, _evt) {
    this.onSelectCb(content);
    this.inputEl.value = content;
    this.inputEl.blur();
    this.close();
  }
};
var VirtualFooterPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    /** Stores pending content injections for preview mode, awaiting DOM availability. */
    this.pendingPreviewInjections = /* @__PURE__ */ new WeakMap();
    /** Manages MutationObservers for views in preview mode to detect when injection targets are ready. */
    this.previewObservers = /* @__PURE__ */ new WeakMap();
    this.initialLayoutReadyProcessed = false;
    /**
     * Handles changes to the active Markdown view, triggering content processing.
     */
    this.handleActiveViewChange = () => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      this._processView(activeView);
    };
  }
  /**
   * Called when the plugin is loaded.
   */
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new VirtualFooterSettingTab(this.app, this));
    const handleFileOpenEvent = () => {
      if (this.settings.refreshOnFileOpen && this.initialLayoutReadyProcessed) {
        this.handleActiveViewChange();
      }
    };
    const handleLayoutChangeEvent = () => {
      if (this.initialLayoutReadyProcessed) {
        this.handleActiveViewChange();
      }
    };
    this.registerEvent(
      this.app.workspace.on("file-open", handleFileOpenEvent)
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", handleLayoutChangeEvent)
    );
    this.app.workspace.onLayoutReady(() => {
      if (!this.initialLayoutReadyProcessed) {
        this.handleActiveViewChange();
        this.initialLayoutReadyProcessed = true;
      }
    });
  }
  /**
   * Called when the plugin is unloaded.
   * Cleans up all injected content and observers.
   */
  async onunload() {
    this.clearAllViewsDynamicContent();
    document.querySelectorAll(`.${CSS_DYNAMIC_CONTENT_ELEMENT}`).forEach((el) => {
      const componentHolder = el;
      if (componentHolder.component) {
        componentHolder.component.unload();
      }
      el.remove();
    });
    document.querySelectorAll(`.${CSS_VIRTUAL_FOOTER_CM_PADDING}`).forEach((el) => el.classList.remove(CSS_VIRTUAL_FOOTER_CM_PADDING));
    document.querySelectorAll(`.${CSS_VIRTUAL_FOOTER_REMOVE_FLEX}`).forEach((el) => el.classList.remove(CSS_VIRTUAL_FOOTER_REMOVE_FLEX));
    this.previewObservers = /* @__PURE__ */ new WeakMap();
    this.pendingPreviewInjections = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Processes a given Markdown view to inject or update dynamic content.
   * @param view The MarkdownView to process.
   */
  async _processView(view) {
    if (!view || !view.file) {
      return;
    }
    await this.removeDynamicContentFromView(view);
    const applicableRulesWithContent = await this._getApplicableRulesAndContent(view.file.path);
    if (applicableRulesWithContent.length === 0) {
      return;
    }
    const viewState = view.getState();
    let combinedHeaderText = "";
    let combinedFooterText = "";
    let hasFooterRule = false;
    const contentSeparator = "\n\n";
    for (const { rule, contentText } of applicableRulesWithContent) {
      if (!contentText || contentText.trim() === "")
        continue;
      if (rule.renderLocation === "header" /* Header */) {
        combinedHeaderText += (combinedHeaderText ? contentSeparator : "") + contentText;
      } else {
        combinedFooterText += (combinedFooterText ? contentSeparator : "") + contentText;
        hasFooterRule = true;
      }
    }
    if (viewState.mode === "source" && !viewState.source && hasFooterRule) {
      this.applyLivePreviewFooterStyles(view);
    }
    let pendingHeaderDiv = null;
    let pendingFooterDiv = null;
    if (viewState.mode === "preview" || viewState.mode === "source" && !viewState.source) {
      if (combinedHeaderText.trim()) {
        const result = await this.renderAndInjectGroupedContent(view, combinedHeaderText, "header" /* Header */);
        if (result && viewState.mode === "preview") {
          pendingHeaderDiv = result;
        }
      }
      if (combinedFooterText.trim()) {
        const result = await this.renderAndInjectGroupedContent(view, combinedFooterText, "footer" /* Footer */);
        if (result && viewState.mode === "preview") {
          pendingFooterDiv = result;
        }
      }
    }
    if (pendingHeaderDiv || pendingFooterDiv) {
      let pending = this.pendingPreviewInjections.get(view);
      if (!pending) {
        pending = {};
        this.pendingPreviewInjections.set(view, pending);
      }
      if (pendingHeaderDiv)
        pending.headerDiv = pendingHeaderDiv;
      if (pendingFooterDiv)
        pending.footerDiv = pendingFooterDiv;
      this.ensurePreviewObserver(view);
    }
  }
  /**
   * Renders combined Markdown content and injects it into the specified location in the view.
   * @param view The MarkdownView to inject content into.
   * @param combinedContentText The combined Markdown string to render.
   * @param renderLocation Specifies whether to render in the header or footer.
   * @returns The rendered HTMLElement if injection is deferred (for preview mode), otherwise null.
   */
  async renderAndInjectGroupedContent(view, combinedContentText, renderLocation) {
    var _a;
    if (!combinedContentText || combinedContentText.trim() === "") {
      return null;
    }
    const isRenderInHeader = renderLocation === "header" /* Header */;
    const sourcePath = ((_a = view.file) == null ? void 0 : _a.path) || "";
    const groupDiv = document.createElement("div");
    groupDiv.className = CSS_DYNAMIC_CONTENT_ELEMENT;
    groupDiv.classList.add(
      isRenderInHeader ? CSS_HEADER_GROUP_ELEMENT : CSS_FOOTER_GROUP_ELEMENT,
      isRenderInHeader ? CSS_HEADER_RENDERED_CONTENT : CSS_FOOTER_RENDERED_CONTENT
    );
    const component = new import_obsidian.Component();
    component.load();
    groupDiv.component = component;
    await import_obsidian.MarkdownRenderer.render(this.app, combinedContentText, groupDiv, sourcePath, component);
    let injectionSuccessful = false;
    const viewState = view.getState();
    if (viewState.mode === "preview") {
      const previewContentParent = view.previewMode.containerEl;
      const targetParent = previewContentParent.querySelector(
        isRenderInHeader ? SELECTOR_PREVIEW_HEADER_AREA : SELECTOR_PREVIEW_FOOTER_AREA
      );
      if (targetParent) {
        targetParent.appendChild(groupDiv);
        injectionSuccessful = true;
      }
    } else if (viewState.mode === "source" && !viewState.source) {
      if (isRenderInHeader) {
        const cmContentContainer = view.containerEl.querySelector(SELECTOR_LIVE_PREVIEW_CONTENT_CONTAINER);
        if (cmContentContainer == null ? void 0 : cmContentContainer.parentElement) {
          cmContentContainer.parentElement.insertBefore(groupDiv, cmContentContainer);
          injectionSuccessful = true;
        }
      } else {
        const targetParent = view.containerEl.querySelector(SELECTOR_EDITOR_SIZER);
        if (targetParent) {
          targetParent.appendChild(groupDiv);
          injectionSuccessful = true;
        }
      }
    }
    if (injectionSuccessful) {
      this.attachInternalLinkHandlers(groupDiv, sourcePath, component);
      return null;
    } else {
      if (viewState.mode === "preview") {
        console.log(`VirtualFooter: Deferring injection for ${renderLocation} in preview mode. Target not found yet.`);
        return groupDiv;
      } else {
        component.unload();
        console.warn(`VirtualFooter: Failed to find injection point for dynamic content group (${renderLocation}). View mode: ${viewState.mode}.`);
        return null;
      }
    }
  }
  /**
   * Ensures a MutationObserver is set up for a view in preview mode to handle deferred content injection.
   * The observer watches for the appearance of target DOM elements.
   * @param view The MarkdownView to observe.
   */
  ensurePreviewObserver(view) {
    var _a;
    if (this.previewObservers.has(view) || !view.file || !((_a = view.previewMode) == null ? void 0 : _a.containerEl)) {
      return;
    }
    const observer = new MutationObserver((_mutations) => {
      var _a2, _b, _c, _d;
      if (!view.file) {
        observer.disconnect();
        this.previewObservers.delete(view);
        const pendingStale = this.pendingPreviewInjections.get(view);
        if (pendingStale) {
          (_b = (_a2 = pendingStale.headerDiv) == null ? void 0 : _a2.component) == null ? void 0 : _b.unload();
          (_d = (_c = pendingStale.footerDiv) == null ? void 0 : _c.component) == null ? void 0 : _d.unload();
          this.pendingPreviewInjections.delete(view);
        }
        return;
      }
      const pending = this.pendingPreviewInjections.get(view);
      if (!pending || !pending.headerDiv && !pending.footerDiv) {
        observer.disconnect();
        this.previewObservers.delete(view);
        if (pending)
          this.pendingPreviewInjections.delete(view);
        return;
      }
      let allResolved = true;
      const sourcePath = view.file.path;
      if (pending.headerDiv) {
        const headerTargetParent = view.previewMode.containerEl.querySelector(SELECTOR_PREVIEW_HEADER_AREA);
        if (headerTargetParent) {
          headerTargetParent.appendChild(pending.headerDiv);
          if (pending.headerDiv.component) {
            this.attachInternalLinkHandlers(pending.headerDiv, sourcePath, pending.headerDiv.component);
          }
          delete pending.headerDiv;
        } else {
          allResolved = false;
        }
      }
      if (pending.footerDiv) {
        const footerTargetParent = view.previewMode.containerEl.querySelector(SELECTOR_PREVIEW_FOOTER_AREA);
        if (footerTargetParent) {
          footerTargetParent.appendChild(pending.footerDiv);
          if (pending.footerDiv.component) {
            this.attachInternalLinkHandlers(pending.footerDiv, sourcePath, pending.footerDiv.component);
          }
          delete pending.footerDiv;
        } else {
          allResolved = false;
        }
      }
      if (allResolved) {
        observer.disconnect();
        this.previewObservers.delete(view);
        this.pendingPreviewInjections.delete(view);
      }
    });
    observer.observe(view.previewMode.containerEl, { childList: true, subtree: true });
    this.previewObservers.set(view, observer);
  }
  /**
   * Applies CSS classes to adjust CodeMirror (Live Preview) layout for footer content.
   * @param view The MarkdownView in Live Preview mode.
   */
  applyLivePreviewFooterStyles(view) {
    const contentEl = view.containerEl.querySelector(SELECTOR_EDITOR_CONTENT_AREA);
    const containerEl = view.containerEl.querySelector(SELECTOR_EDITOR_CONTENT_CONTAINER_PARENT);
    contentEl == null ? void 0 : contentEl.classList.add(CSS_VIRTUAL_FOOTER_CM_PADDING);
    containerEl == null ? void 0 : containerEl.classList.add(CSS_VIRTUAL_FOOTER_REMOVE_FLEX);
  }
  /**
   * Removes CSS classes used for Live Preview footer layout adjustments.
   * @param viewOrContainer The MarkdownView or a specific HTMLElement container.
   */
  removeLivePreviewFooterStyles(viewOrContainer) {
    const container = viewOrContainer instanceof import_obsidian.MarkdownView ? viewOrContainer.containerEl : viewOrContainer;
    const contentEl = container.querySelector(SELECTOR_EDITOR_CONTENT_AREA);
    const containerEl = container.querySelector(SELECTOR_EDITOR_CONTENT_CONTAINER_PARENT);
    contentEl == null ? void 0 : contentEl.classList.remove(CSS_VIRTUAL_FOOTER_CM_PADDING);
    containerEl == null ? void 0 : containerEl.classList.remove(CSS_VIRTUAL_FOOTER_REMOVE_FLEX);
  }
  /**
   * Removes all plugin-injected DOM elements from a given container.
   * @param containerEl The HTMLElement to search within.
   */
  async removeInjectedContentDOM(containerEl) {
    containerEl.querySelectorAll(`.${CSS_DYNAMIC_CONTENT_ELEMENT}`).forEach((el) => {
      const componentHolder = el;
      if (componentHolder.component) {
        componentHolder.component.unload();
      }
      el.remove();
    });
  }
  /**
   * Removes all dynamic content, styles, and observers associated with a specific view.
   * @param view The MarkdownView to clean up.
   */
  async removeDynamicContentFromView(view) {
    var _a, _b, _c, _d;
    this.removeLivePreviewFooterStyles(view);
    await this.removeInjectedContentDOM(view.containerEl);
    const observer = this.previewObservers.get(view);
    if (observer) {
      observer.disconnect();
      this.previewObservers.delete(view);
    }
    const pending = this.pendingPreviewInjections.get(view);
    if (pending) {
      (_b = (_a = pending.headerDiv) == null ? void 0 : _a.component) == null ? void 0 : _b.unload();
      (_d = (_c = pending.footerDiv) == null ? void 0 : _c.component) == null ? void 0 : _d.unload();
      this.pendingPreviewInjections.delete(view);
    }
  }
  /**
   * Clears dynamic content from all currently open Markdown views.
   * Typically used during plugin unload or when global settings change significantly.
   */
  clearAllViewsDynamicContent() {
    this.app.workspace.getLeavesOfType("markdown").forEach((leaf) => {
      if (leaf.view instanceof import_obsidian.MarkdownView) {
        this.removeDynamicContentFromView(leaf.view);
      }
    });
  }
  /**
   * Determines which rules apply to a given file path and fetches their content.
   * @param filePath The path of the file to check against rules.
   * @returns A promise that resolves to an array of objects, each containing an applicable rule and its content.
   */
  async _getApplicableRulesAndContent(filePath) {
    var _a, _b, _c, _d;
    const allApplicable = [];
    const abstractFile = this.app.vault.getAbstractFileByPath(filePath);
    if (!(abstractFile instanceof import_obsidian.TFile)) {
      return [];
    }
    const file = abstractFile;
    let fileTags = null;
    const fileCache = this.app.metadataCache.getFileCache(file);
    const hasEnabledTagRule = this.settings.rules.some((r) => r.enabled && r.type === "tag" /* Tag */);
    if (hasEnabledTagRule && fileCache) {
      const allTagsInFileWithHash = (0, import_obsidian.getAllTags)(fileCache);
      fileTags = allTagsInFileWithHash ? allTagsInFileWithHash.map((tag) => tag.substring(1)) : [];
    }
    for (const currentRule of this.settings.rules) {
      if (!currentRule.enabled) {
        continue;
      }
      let isMatch = false;
      const ruleRecursive = currentRule.recursive === void 0 ? true : currentRule.recursive;
      if (currentRule.type === "folder" /* Folder */ && currentRule.path !== void 0) {
        if (currentRule.path === "") {
          isMatch = true;
        } else if (currentRule.path === "/") {
          isMatch = ruleRecursive ? true : (_b = (_a = file.parent) == null ? void 0 : _a.isRoot()) != null ? _b : false;
        } else {
          let normalizedRuleFolderPath = currentRule.path.endsWith("/") ? currentRule.path.slice(0, -1) : currentRule.path;
          if (ruleRecursive) {
            isMatch = file.path.startsWith(normalizedRuleFolderPath + "/");
          } else {
            isMatch = ((_c = file.parent) == null ? void 0 : _c.path) === normalizedRuleFolderPath;
          }
        }
      } else if (currentRule.type === "tag" /* Tag */ && currentRule.tag && fileTags) {
        const ruleTag = currentRule.tag;
        const includeSubtags = (_d = currentRule.includeSubtags) != null ? _d : false;
        for (const fileTag of fileTags) {
          if (includeSubtags) {
            if (fileTag === ruleTag || fileTag.startsWith(ruleTag + "/")) {
              isMatch = true;
              break;
            }
          } else {
            if (fileTag === ruleTag) {
              isMatch = true;
              break;
            }
          }
        }
      } else if (currentRule.type === "property" /* Property */ && currentRule.propertyName && (fileCache == null ? void 0 : fileCache.frontmatter)) {
        const propertyKey = currentRule.propertyName;
        const expectedPropertyValue = currentRule.propertyValue;
        const actualPropertyValue = fileCache.frontmatter[propertyKey];
        if (actualPropertyValue !== void 0 && actualPropertyValue !== null) {
          if (typeof actualPropertyValue === "string") {
            isMatch = actualPropertyValue === expectedPropertyValue;
          } else if (Array.isArray(actualPropertyValue)) {
            isMatch = actualPropertyValue.map(String).includes(expectedPropertyValue);
          } else if (typeof actualPropertyValue === "number" || typeof actualPropertyValue === "boolean") {
            isMatch = String(actualPropertyValue) === expectedPropertyValue;
          }
        }
      }
      if (isMatch) {
        const contentText = await this._fetchContentForRule(currentRule);
        allApplicable.push({ rule: currentRule, contentText });
      }
    }
    return allApplicable;
  }
  /**
   * Fetches the content for a given rule, either from direct text or from a specified file.
   * @param rule The rule for which to fetch content.
   * @returns A promise that resolves to the content string.
   */
  async _fetchContentForRule(rule) {
    if (rule.contentSource === "file" /* File */ && rule.footerFilePath) {
      const file = this.app.vault.getAbstractFileByPath(rule.footerFilePath);
      if (file instanceof import_obsidian.TFile) {
        try {
          return await this.app.vault.cachedRead(file);
        } catch (error) {
          console.error(`VirtualFooter: Error reading content file ${rule.footerFilePath}`, error);
          return `<!-- Error reading content file: ${rule.footerFilePath} -->`;
        }
      } else {
        console.warn(`VirtualFooter: Content file not found for rule: ${rule.footerFilePath}`);
        return `<!-- Content file not found: ${rule.footerFilePath} -->`;
      }
    }
    return rule.footerText || "";
  }
  /**
   * Attaches event handlers to the injected content for internal link navigation.
   * @param container The HTMLElement containing the rendered Markdown.
   * @param sourcePath The path of the file where the content is injected, for link resolution.
   * @param component The Obsidian Component associated with this content, for event registration.
   */
  attachInternalLinkHandlers(container, sourcePath, component) {
    component.registerDomEvent(container, "click", (event) => {
      if (event.button !== 0)
        return;
      const target = event.target;
      const linkElement = target.closest("a.internal-link");
      if (linkElement) {
        event.preventDefault();
        const href = linkElement.dataset.href;
        if (href) {
          const inNewPane = event.ctrlKey || event.metaKey;
          this.app.workspace.openLinkText(href, sourcePath, inNewPane);
        }
      }
    });
    component.registerDomEvent(container, "auxclick", (event) => {
      if (event.button !== 1)
        return;
      const target = event.target;
      const linkElement = target.closest("a.internal-link");
      if (linkElement) {
        event.preventDefault();
        const href = linkElement.dataset.href;
        if (href) {
          this.app.workspace.openLinkText(href, sourcePath, true);
        }
      }
    });
  }
  /**
   * Loads plugin settings from storage, migrating old formats if necessary.
   */
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
    if (loadedData) {
      const oldGlobalRenderLocation = loadedData.renderLocation;
      if (loadedData.rules && Array.isArray(loadedData.rules)) {
        this.settings.rules = loadedData.rules.map(
          (loadedRule) => this._migrateRule(loadedRule, oldGlobalRenderLocation)
        );
      }
      if (typeof loadedData.refreshOnFileOpen === "boolean") {
        this.settings.refreshOnFileOpen = loadedData.refreshOnFileOpen;
      }
    }
    if (!this.settings.rules || this.settings.rules.length === 0) {
      this.settings.rules = [JSON.parse(JSON.stringify(DEFAULT_SETTINGS.rules[0]))];
      this.normalizeRule(this.settings.rules[0]);
    } else {
      this.settings.rules.forEach((rule) => this.normalizeRule(rule));
    }
    if (typeof this.settings.refreshOnFileOpen !== "boolean") {
      this.settings.refreshOnFileOpen = DEFAULT_SETTINGS.refreshOnFileOpen;
    }
  }
  /**
   * Migrates a rule from an older settings format to the current Rule interface.
   * @param loadedRule The rule object loaded from storage.
   * @param globalRenderLocation An optional global render location from a very old settings format.
   * @returns A migrated and normalized Rule object.
   */
  _migrateRule(loadedRule, globalRenderLocation) {
    let type;
    if (Object.values(RuleType).includes(loadedRule.type)) {
      type = loadedRule.type;
    } else if (typeof loadedRule.folderPath === "string") {
      type = "folder" /* Folder */;
    } else {
      type = DEFAULT_SETTINGS.rules[0].type;
    }
    let contentSource;
    if (Object.values(ContentSource).includes(loadedRule.contentSource)) {
      contentSource = loadedRule.contentSource;
    } else {
      contentSource = typeof loadedRule.folderPath === "string" && loadedRule.contentSource === void 0 ? "text" /* Text */ : DEFAULT_SETTINGS.rules[0].contentSource;
    }
    const migratedRule = {
      name: loadedRule.name || DEFAULT_SETTINGS.rules[0].name,
      enabled: loadedRule.enabled !== void 0 ? loadedRule.enabled : DEFAULT_SETTINGS.rules[0].enabled,
      type,
      contentSource,
      footerText: loadedRule.footerText || "",
      // Retain name for compatibility
      renderLocation: loadedRule.renderLocation || globalRenderLocation || DEFAULT_SETTINGS.rules[0].renderLocation,
      recursive: loadedRule.recursive !== void 0 ? loadedRule.recursive : true
    };
    if (migratedRule.type === "folder" /* Folder */) {
      migratedRule.path = loadedRule.path !== void 0 ? loadedRule.path : loadedRule.folderPath !== void 0 ? loadedRule.folderPath : DEFAULT_SETTINGS.rules[0].path;
    } else if (migratedRule.type === "tag" /* Tag */) {
      migratedRule.tag = loadedRule.tag !== void 0 ? loadedRule.tag : "";
      migratedRule.includeSubtags = loadedRule.includeSubtags !== void 0 ? loadedRule.includeSubtags : false;
    } else if (migratedRule.type === "property" /* Property */) {
      migratedRule.propertyName = loadedRule.propertyName || "";
      migratedRule.propertyValue = loadedRule.propertyValue || "";
    }
    if (migratedRule.contentSource === "file" /* File */) {
      migratedRule.footerFilePath = loadedRule.footerFilePath || "";
    }
    return migratedRule;
  }
  /**
   * Normalizes a rule object, ensuring all required fields are present and defaults are applied.
   * Also cleans up fields that are not relevant to the rule's current type or content source.
   * @param rule The rule to normalize.
   */
  normalizeRule(rule) {
    rule.name = rule.name === void 0 ? DEFAULT_SETTINGS.rules[0].name : rule.name;
    rule.enabled = typeof rule.enabled === "boolean" ? rule.enabled : DEFAULT_SETTINGS.rules[0].enabled;
    rule.type = rule.type || DEFAULT_SETTINGS.rules[0].type;
    if (rule.type === "folder" /* Folder */) {
      rule.path = rule.path === void 0 ? DEFAULT_SETTINGS.rules[0].path || "" : rule.path;
      rule.recursive = rule.path === "" ? true : typeof rule.recursive === "boolean" ? rule.recursive : true;
      delete rule.tag;
      delete rule.includeSubtags;
      delete rule.propertyName;
      delete rule.propertyValue;
    } else if (rule.type === "tag" /* Tag */) {
      rule.tag = rule.tag === void 0 ? "" : rule.tag;
      rule.includeSubtags = typeof rule.includeSubtags === "boolean" ? rule.includeSubtags : false;
      delete rule.path;
      delete rule.recursive;
      delete rule.propertyName;
      delete rule.propertyValue;
    } else if (rule.type === "property" /* Property */) {
      rule.propertyName = rule.propertyName === void 0 ? "" : rule.propertyName;
      rule.propertyValue = rule.propertyValue === void 0 ? "" : rule.propertyValue;
      delete rule.path;
      delete rule.recursive;
      delete rule.tag;
      delete rule.includeSubtags;
    }
    rule.contentSource = rule.contentSource || DEFAULT_SETTINGS.rules[0].contentSource;
    rule.footerText = rule.footerText || "";
    rule.renderLocation = rule.renderLocation || DEFAULT_SETTINGS.rules[0].renderLocation;
    if (rule.contentSource === "file" /* File */) {
      rule.footerFilePath = rule.footerFilePath || "";
    } else {
      delete rule.footerFilePath;
    }
  }
  /**
   * Saves the current plugin settings to storage and triggers a view refresh.
   */
  async saveSettings() {
    this.settings.rules.forEach((rule) => this.normalizeRule(rule));
    await this.saveData(this.settings);
    this.handleActiveViewChange();
  }
};
var VirtualFooterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    // Caches for suggestion lists to improve performance
    this.allFolderPathsCache = null;
    this.allTagsCache = null;
    this.allMarkdownFilePathsCache = null;
    this.allPropertyNamesCache = null;
    this.ruleExpandedStates = [];
  }
  /**
   * Lazily gets and caches all unique folder paths in the vault.
   * Includes special paths "" (all files) and "/" (root).
   * @returns A set of available folder paths.
   */
  getAvailableFolderPaths() {
    if (this.allFolderPathsCache)
      return this.allFolderPathsCache;
    const paths = /* @__PURE__ */ new Set(["/", ""]);
    this.app.vault.getAllLoadedFiles().forEach((file) => {
      if (file.parent) {
        const parentPath = file.parent.isRoot() ? "/" : file.parent.path.endsWith("/") ? file.parent.path : file.parent.path + "/";
        if (parentPath !== "/")
          paths.add(parentPath);
      }
      if ("children" in file && file.path !== "/") {
        const folderPath = file.path.endsWith("/") ? file.path : file.path + "/";
        paths.add(folderPath);
      }
    });
    this.allFolderPathsCache = paths;
    return paths;
  }
  /**
   * Lazily gets and caches all unique tags (without '#') present in Markdown files.
   * @returns A set of available tags.
   */
  getAvailableTags() {
    if (this.allTagsCache)
      return this.allTagsCache;
    const collectedTags = /* @__PURE__ */ new Set();
    this.app.vault.getMarkdownFiles().forEach((file) => {
      const fileCache = this.app.metadataCache.getFileCache(file);
      if (fileCache) {
        const tagsInFile = (0, import_obsidian.getAllTags)(fileCache);
        tagsInFile == null ? void 0 : tagsInFile.forEach((tag) => {
          collectedTags.add(tag.substring(1));
        });
      }
    });
    this.allTagsCache = collectedTags;
    return collectedTags;
  }
  /**
   * Lazily gets and caches all Markdown file paths in the vault.
   * @returns A set of available Markdown file paths.
   */
  getAvailableMarkdownFilePaths() {
    if (this.allMarkdownFilePathsCache)
      return this.allMarkdownFilePathsCache;
    const paths = /* @__PURE__ */ new Set();
    this.app.vault.getMarkdownFiles().forEach((file) => {
      paths.add(file.path);
    });
    this.allMarkdownFilePathsCache = paths;
    return paths;
  }
  /**
   * Lazily gets and caches all unique frontmatter property keys from Markdown files.
   * @returns A set of available property names.
   */
  getAvailablePropertyNames() {
    var _a, _b;
    if (this.allPropertyNamesCache)
      return this.allPropertyNamesCache;
    const keys = ((_b = (_a = this.app.metadataCache).getFrontmatterPropertyKeys) == null ? void 0 : _b.call(_a)) || [];
    this.allPropertyNamesCache = new Set(keys);
    return this.allPropertyNamesCache;
  }
  /**
   * Renders the settings tab UI.
   * This method is called by Obsidian when the settings tab is opened.
   */
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Virtual Content Settings" });
    containerEl.createEl("p", { text: "Define rules to dynamically add content to the header or footer of notes based on their folder, tags, or properties." });
    new import_obsidian.Setting(containerEl).setName("Refresh on focus change").setDesc("If enabled, virtual content will refresh when switching files. This may cause a slight flicker but is useful if you frequently change the text of virtual content and need immediate updates. If disabled the virtual content will be updated on file open and view change (editing/reading view). Disabled by default.").addToggle((toggle) => toggle.setValue(this.plugin.settings.refreshOnFileOpen).onChange(async (value) => {
      this.plugin.settings.refreshOnFileOpen = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Rules" });
    this.allFolderPathsCache = null;
    this.allTagsCache = null;
    this.allMarkdownFilePathsCache = null;
    this.allPropertyNamesCache = null;
    const numRules = this.plugin.settings.rules.length;
    while (this.ruleExpandedStates.length < numRules) {
      this.ruleExpandedStates.push(false);
    }
    if (this.ruleExpandedStates.length > numRules) {
      this.ruleExpandedStates.length = numRules;
    }
    const rulesContainer = containerEl.createDiv("rules-container virtual-footer-rules-container");
    if (!this.plugin.settings.rules) {
      this.plugin.settings.rules = [];
    }
    if (this.plugin.settings.rules.length === 0) {
      const newRule = JSON.parse(JSON.stringify(DEFAULT_SETTINGS.rules[0]));
      this.plugin.normalizeRule(newRule);
      this.plugin.settings.rules.push(newRule);
      if (this.ruleExpandedStates.length === 0) {
        this.ruleExpandedStates.push(false);
      }
    }
    this.plugin.settings.rules.forEach((rule, index) => {
      this.renderRuleControls(rule, index, rulesContainer);
    });
    new import_obsidian.Setting(containerEl).addButton((button) => button.setButtonText("Add new rule").setCta().setClass("virtual-footer-add-button").onClick(async () => {
      const newRule = JSON.parse(JSON.stringify(DEFAULT_SETTINGS.rules[0]));
      this.plugin.normalizeRule(newRule);
      this.plugin.settings.rules.push(newRule);
      this.ruleExpandedStates.push(true);
      await this.plugin.saveSettings();
      this.display();
    }));
  }
  /**
   * Renders the UI controls for a single rule within the settings tab.
   * @param rule The rule object to render controls for.
   * @param index The index of the rule in the settings array.
   * @param containerEl The parent HTMLElement to append the rule controls to.
   */
  renderRuleControls(rule, index, containerEl) {
    const ruleDiv = containerEl.createDiv("rule-item virtual-footer-rule-item");
    if (!this.ruleExpandedStates[index]) {
      ruleDiv.addClass("is-collapsed");
    }
    const ruleNameDisplay = rule.name && rule.name.trim() !== "" ? rule.name : "Unnamed Rule";
    const ruleHeadingText = `Rule ${index + 1}: ${ruleNameDisplay}`;
    const ruleHeading = ruleDiv.createEl("h4", { text: ruleHeadingText });
    ruleHeading.addClass("virtual-footer-rule-heading");
    const ruleContentContainer = ruleDiv.createDiv("virtual-footer-rule-content");
    ruleHeading.addEventListener("click", () => {
      const isNowExpanded = !ruleDiv.classList.toggle("is-collapsed");
      this.ruleExpandedStates[index] = isNowExpanded;
    });
    new import_obsidian.Setting(ruleContentContainer).setName("Rule name").setDesc('A descriptive name for this rule (e.g., "Project Notes Footer").').addText((text) => text.setPlaceholder("e.g., Blog Post Footer").setValue(rule.name || "").onChange(async (value) => {
      rule.name = value;
      const newNameDisplay = value && value.trim() !== "" ? value : "Unnamed Rule";
      ruleHeading.textContent = `Rule ${index + 1}: ${newNameDisplay}`;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(ruleContentContainer).setName("Enabled").setDesc("If disabled, this rule will not be applied.").addToggle((toggle) => toggle.setValue(rule.enabled).onChange(async (value) => {
      rule.enabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(ruleContentContainer).setName("Rule type").setDesc("Apply this rule based on folder, tag, or property.").addDropdown((dropdown) => dropdown.addOption("folder" /* Folder */, "Folder").addOption("tag" /* Tag */, "Tag").addOption("property" /* Property */, "Property").setValue(rule.type).onChange(async (value) => {
      rule.type = value;
      this.plugin.normalizeRule(rule);
      await this.plugin.saveSettings();
      this.display();
    }));
    if (rule.type === "folder" /* Folder */) {
      new import_obsidian.Setting(ruleContentContainer).setName("Folder path").setDesc('Path for the rule. Use "" for all files, "/" for root folder, or "FolderName/" for specific folders (ensure trailing slash for non-root folders).').addText((text) => {
        text.setPlaceholder("e.g., Meetings/, /, or empty for all").setValue(rule.path || "").onChange(async (value) => {
          rule.path = value;
          this.plugin.normalizeRule(rule);
          await this.plugin.saveSettings();
          this.display();
        });
        new MultiSuggest(text.inputEl, this.getAvailableFolderPaths(), (selectedPath) => {
          rule.path = selectedPath;
          this.plugin.normalizeRule(rule);
          text.setValue(selectedPath);
          this.plugin.saveSettings().then(() => this.display());
        }, this.plugin.app);
      });
      new import_obsidian.Setting(ruleContentContainer).setName("Include subfolders (recursive)").setDesc('If enabled, rule applies to files in subfolders. For "all files" (empty path), this is always true. For root path ("/"), enabling applies to all vault files, disabling applies only to files directly in the root.').addToggle((toggle) => {
        toggle.setValue(rule.recursive).onChange(async (value) => {
          rule.recursive = value;
          await this.plugin.saveSettings();
        });
        if (rule.path === "") {
          toggle.setDisabled(true);
        }
      });
    } else if (rule.type === "tag" /* Tag */) {
      new import_obsidian.Setting(ruleContentContainer).setName("Tag value").setDesc('Tag to match (without the # prefix). E.g., "project" or "status/done".').addText((text) => {
        text.setPlaceholder("e.g., important or project/alpha").setValue(rule.tag || "").onChange(async (value) => {
          rule.tag = value.startsWith("#") ? value.substring(1) : value;
          await this.plugin.saveSettings();
        });
        new MultiSuggest(text.inputEl, this.getAvailableTags(), (selectedTag) => {
          const normalizedTag = selectedTag.startsWith("#") ? selectedTag.substring(1) : selectedTag;
          rule.tag = normalizedTag;
          text.setValue(normalizedTag);
          this.plugin.saveSettings();
        }, this.plugin.app);
      });
      new import_obsidian.Setting(ruleContentContainer).setName("Include subtags").setDesc("If enabled, a rule for 'tag' will also apply to 'tag/subtag1', 'tag/subtag2/subtag3', etc. If disabled, it only applies to the exact tag.").addToggle((toggle) => {
        toggle.setValue(rule.includeSubtags).onChange(async (value) => {
          rule.includeSubtags = value;
          await this.plugin.saveSettings();
        });
      });
    } else if (rule.type === "property" /* Property */) {
      new import_obsidian.Setting(ruleContentContainer).setName("Property name").setDesc("The name of the Obsidian property (frontmatter key) to match.").addText((text) => {
        text.setPlaceholder("e.g., status, type, author").setValue(rule.propertyName || "").onChange(async (value) => {
          rule.propertyName = value;
          await this.plugin.saveSettings();
        });
        new MultiSuggest(text.inputEl, this.getAvailablePropertyNames(), (selectedName) => {
          rule.propertyName = selectedName;
          text.setValue(selectedName);
          this.plugin.saveSettings();
        }, this.plugin.app);
      });
      new import_obsidian.Setting(ruleContentContainer).setName("Property value").setDesc("The value the property should have. For list/array properties, matches if this value is one of the items.").addText((text) => text.setPlaceholder("e.g., complete, article, John Doe").setValue(rule.propertyValue || "").onChange(async (value) => {
        rule.propertyValue = value;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian.Setting(ruleContentContainer).setName("Content source").setDesc("Where to get the content from: direct text input or a separate Markdown file.").addDropdown((dropdown) => dropdown.addOption("text" /* Text */, "Direct text").addOption("file" /* File */, "Markdown file").setValue(rule.contentSource || "text" /* Text */).onChange(async (value) => {
      rule.contentSource = value;
      this.plugin.normalizeRule(rule);
      await this.plugin.saveSettings();
      this.display();
    }));
    if (rule.contentSource === "file" /* File */) {
      new import_obsidian.Setting(ruleContentContainer).setName("Content file path").setDesc('Path to the .md file to use as content (e.g., "templates/common-footer.md").').addText((text) => {
        text.setPlaceholder("e.g., templates/common-footer.md").setValue(rule.footerFilePath || "").onChange(async (value) => {
          rule.footerFilePath = value;
          await this.plugin.saveSettings();
        });
        new MultiSuggest(text.inputEl, this.getAvailableMarkdownFilePaths(), (selectedPath) => {
          rule.footerFilePath = selectedPath;
          text.setValue(selectedPath);
          this.plugin.saveSettings();
        }, this.plugin.app);
      });
    } else {
      new import_obsidian.Setting(ruleContentContainer).setName("Content text").setDesc("Markdown text to display. This will be rendered.").addTextArea((text) => text.setPlaceholder("Enter your markdown content here...\nSupports multiple lines and **Markdown** formatting.").setValue(rule.footerText || "").onChange(async (value) => {
        rule.footerText = value;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian.Setting(ruleContentContainer).setName("Render location").setDesc("Choose whether this rule renders its content in the header or footer of the note.").addDropdown((dropdown) => dropdown.addOption("footer" /* Footer */, "Footer").addOption("header" /* Header */, "Header").setValue(rule.renderLocation || "footer" /* Footer */).onChange(async (value) => {
      rule.renderLocation = value;
      await this.plugin.saveSettings();
    }));
    const ruleActionsSetting = new import_obsidian.Setting(ruleContentContainer).setClass("virtual-footer-rule-actions");
    ruleActionsSetting.addButton((button) => button.setIcon("arrow-up").setTooltip("Move rule up").setClass("virtual-footer-move-button").setDisabled(index === 0).onClick(async () => {
      if (index > 0) {
        const rules = this.plugin.settings.rules;
        const ruleToMove = rules.splice(index, 1)[0];
        rules.splice(index - 1, 0, ruleToMove);
        const expandedStateToMove = this.ruleExpandedStates.splice(index, 1)[0];
        this.ruleExpandedStates.splice(index - 1, 0, expandedStateToMove);
        await this.plugin.saveSettings();
        this.display();
      }
    }));
    ruleActionsSetting.addButton((button) => button.setIcon("arrow-down").setTooltip("Move rule down").setClass("virtual-footer-move-button").setDisabled(index === this.plugin.settings.rules.length - 1).onClick(async () => {
      if (index < this.plugin.settings.rules.length - 1) {
        const rules = this.plugin.settings.rules;
        const ruleToMove = rules.splice(index, 1)[0];
        rules.splice(index + 1, 0, ruleToMove);
        const expandedStateToMove = this.ruleExpandedStates.splice(index, 1)[0];
        this.ruleExpandedStates.splice(index + 1, 0, expandedStateToMove);
        await this.plugin.saveSettings();
        this.display();
      }
    }));
    ruleActionsSetting.controlEl.createDiv({ cls: "virtual-footer-actions-spacer" });
    ruleActionsSetting.addButton((button) => button.setButtonText("Delete rule").setWarning().setClass("virtual-footer-delete-button").onClick(async () => {
      this.plugin.settings.rules.splice(index, 1);
      this.ruleExpandedStates.splice(index, 1);
      await this.plugin.saveSettings();
      this.display();
    }));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHtcblx0QXBwLFxuXHRQbHVnaW4sXG5cdFBsdWdpblNldHRpbmdUYWIsXG5cdFNldHRpbmcsXG5cdE1hcmtkb3duVmlldyxcblx0TWFya2Rvd25SZW5kZXJlcixcblx0QWJzdHJhY3RJbnB1dFN1Z2dlc3QsXG5cdENvbXBvbmVudCxcblx0VEZpbGUsXG5cdGdldEFsbFRhZ3MsXG59IGZyb20gJ29ic2lkaWFuJztcblxuLy8gLS0tIEVudW1zIC0tLVxuXG4vKiogRGVmaW5lcyB0aGUgdHlwZSBvZiBhIHJ1bGUsIGRldGVybWluaW5nIGhvdyBpdCBtYXRjaGVzIGZpbGVzIChlLmcuLCBieSBmb2xkZXIsIHRhZywgb3IgcHJvcGVydHkpLiAqL1xuZW51bSBSdWxlVHlwZSB7XG5cdEZvbGRlciA9ICdmb2xkZXInLFxuXHRUYWcgPSAndGFnJyxcblx0UHJvcGVydHkgPSAncHJvcGVydHknLFxufVxuXG4vKiogRGVmaW5lcyB0aGUgc291cmNlIG9mIHRoZSBjb250ZW50IGZvciBhIHJ1bGUgKGUuZy4sIGRpcmVjdCB0ZXh0IGlucHV0IG9yIGEgbWFya2Rvd24gZmlsZSkuICovXG5lbnVtIENvbnRlbnRTb3VyY2Uge1xuXHRUZXh0ID0gJ3RleHQnLFxuXHRGaWxlID0gJ2ZpbGUnLFxufVxuXG4vKiogRGVmaW5lcyB3aGVyZSB0aGUgZHluYW1pYyBjb250ZW50IHNob3VsZCBiZSByZW5kZXJlZCB3aXRoaW4gdGhlIE1hcmtkb3duIHZpZXcgKGUuZy4sIGhlYWRlciBvciBmb290ZXIpLiAqL1xuZW51bSBSZW5kZXJMb2NhdGlvbiB7XG5cdEZvb3RlciA9ICdmb290ZXInLFxuXHRIZWFkZXIgPSAnaGVhZGVyJyxcbn1cblxuLy8gLS0tIEludGVyZmFjZXMgLS0tXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHJ1bGUgZm9yIGluamVjdGluZyBkeW5hbWljIGNvbnRlbnQgaW50byBNYXJrZG93biB2aWV3cy5cbiAqIEVhY2ggcnVsZSBzcGVjaWZpZXMgbWF0Y2hpbmcgY3JpdGVyaWEgKHR5cGU6IGZvbGRlci90YWcvcHJvcGVydHkpLCBjb250ZW50IHNvdXJjZSAodGV4dC9maWxlKSxcbiAqIHRoZSBjb250ZW50IGl0c2VsZiwgYW5kIHdoZXJlIGl0IHNob3VsZCBiZSByZW5kZXJlZCAoaGVhZGVyL2Zvb3RlcikuXG4gKi9cbmludGVyZmFjZSBSdWxlIHtcblx0LyoqIEEgZGVzY3JpcHRpdmUgbmFtZSBmb3IgdGhpcyBydWxlLiAqL1xuXHRuYW1lPzogc3RyaW5nO1xuXHQvKiogV2hldGhlciB0aGlzIHJ1bGUgaXMgY3VycmVudGx5IGFjdGl2ZS4gKi9cblx0ZW5hYmxlZD86IGJvb2xlYW47XG5cdC8qKiBUaGUgdHlwZSBvZiBjcml0ZXJpYSBmb3IgdGhpcyBydWxlIChmb2xkZXItYmFzZWQsIHRhZy1iYXNlZCwgb3IgcHJvcGVydHktYmFzZWQpLiAqL1xuXHR0eXBlOiBSdWxlVHlwZTtcblx0LyoqIEZvciAnZm9sZGVyJyB0eXBlOiBwYXRoIHRvIHRoZSBmb2xkZXIuIFwiXCIgZm9yIGFsbCBmaWxlcywgXCIvXCIgZm9yIHJvb3QuICovXG5cdHBhdGg/OiBzdHJpbmc7XG5cdC8qKiBGb3IgJ3RhZycgdHlwZTogdGhlIHRhZyBuYW1lICh3aXRob3V0ICcjJykuICovXG5cdHRhZz86IHN0cmluZztcblx0LyoqIEZvciAnZm9sZGVyJyB0eXBlOiB3aGV0aGVyIHRvIG1hdGNoIHN1YmZvbGRlcnMuIERlZmF1bHRzIHRvIHRydWUuIElnbm9yZWQgaWYgcGF0aCBpcyBcIlwiLiAqL1xuXHRyZWN1cnNpdmU/OiBib29sZWFuO1xuXHQvKiogRm9yICd0YWcnIHR5cGU6IHdoZXRoZXIgdG8gbWF0Y2ggc3VidGFncyAoZS5nLiwgJ3RhZycgbWF0Y2hlcyAndGFnL3N1YnRhZycpLiBEZWZhdWx0cyB0byBmYWxzZS4gKi9cblx0aW5jbHVkZVN1YnRhZ3M/OiBib29sZWFuO1xuXHQvKiogRm9yICdwcm9wZXJ0eScgdHlwZTogdGhlIG5hbWUgb2YgdGhlIGZyb250bWF0dGVyIHByb3BlcnR5LiAqL1xuXHRwcm9wZXJ0eU5hbWU/OiBzdHJpbmc7XG5cdC8qKiBGb3IgJ3Byb3BlcnR5JyB0eXBlOiB0aGUgdmFsdWUgdGhlIGZyb250bWF0dGVyIHByb3BlcnR5IHNob3VsZCBoYXZlLiAqL1xuXHRwcm9wZXJ0eVZhbHVlPzogc3RyaW5nO1xuXHQvKiogVGhlIHNvdXJjZSBmcm9tIHdoaWNoIHRvIGdldCB0aGUgY29udGVudCAoZGlyZWN0IHRleHQgb3IgYSBmaWxlKS4gKi9cblx0Y29udGVudFNvdXJjZTogQ29udGVudFNvdXJjZTtcblx0LyoqIERpcmVjdCB0ZXh0IGNvbnRlbnQgaWYgY29udGVudFNvdXJjZSBpcyAndGV4dCcuICovXG5cdGZvb3RlclRleHQ6IHN0cmluZzsgLy8gUmV0YWluZWQgbmFtZSBmb3IgY29tcGF0aWJpbGl0eSwgdGhvdWdoIGl0IGNhbiBiZSBoZWFkZXIgb3IgZm9vdGVyIGNvbnRlbnQuXG5cdC8qKiBQYXRoIHRvIGEgLm1kIGZpbGUgaWYgY29udGVudFNvdXJjZSBpcyAnZmlsZScuICovXG5cdGZvb3RlckZpbGVQYXRoPzogc3RyaW5nOyAvLyBSZXRhaW5lZCBuYW1lIGZvciBjb21wYXRpYmlsaXR5LlxuXHQvKiogU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmVuZGVyIGluIHRoZSBoZWFkZXIgb3IgZm9vdGVyLiAqL1xuXHRyZW5kZXJMb2NhdGlvbjogUmVuZGVyTG9jYXRpb247XG59XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgc2V0dGluZ3Mgc3RydWN0dXJlIGZvciB0aGUgVmlydHVhbEZvb3RlciBwbHVnaW4uXG4gKiBDb250YWlucyBhbiBhcnJheSBvZiBydWxlcyB0aGF0IGRpY3RhdGUgY29udGVudCBpbmplY3Rpb24uXG4gKi9cbmludGVyZmFjZSBWaXJ0dWFsRm9vdGVyU2V0dGluZ3Mge1xuXHRydWxlczogUnVsZVtdO1xuXHQvKiogV2hldGhlciB0byByZWZyZXNoIHRoZSB2aWV3IG9uIGZpbGUgb3Blbi4gRGVmYXVsdHMgdG8gZmFsc2UuICovXG5cdHJlZnJlc2hPbkZpbGVPcGVuPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIEhUTUxFbGVtZW50IHRvIGFzc29jaWF0ZSBhbiBPYnNpZGlhbiBDb21wb25lbnQgZm9yIGxpZmVjeWNsZSBtYW5hZ2VtZW50LlxuICogVGhpcyBhbGxvd3MgT2JzaWRpYW4gdG8gbWFuYWdlIHJlc291cmNlcyB0aWVkIHRvIHRoZSBET00gZWxlbWVudC5cbiAqL1xuaW50ZXJmYWNlIEhUTUxFbGVtZW50V2l0aENvbXBvbmVudCBleHRlbmRzIEhUTUxFbGVtZW50IHtcblx0LyoqIFRoZSBPYnNpZGlhbiBDb21wb25lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgSFRNTCBlbGVtZW50LiAqL1xuXHRjb21wb25lbnQ/OiBDb21wb25lbnQ7XG59XG5cbi8vIC0tLSBDb25zdGFudHMgLS0tXG5cbi8qKiBEZWZhdWx0IHNldHRpbmdzIGZvciB0aGUgcGx1Z2luLCB1c2VkIHdoZW4gbm8gc2V0dGluZ3MgYXJlIGZvdW5kIG9yIGZvciBuZXcgcnVsZXMuICovXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBWaXJ0dWFsRm9vdGVyU2V0dGluZ3MgPSB7XG5cdHJ1bGVzOiBbe1xuXHRcdG5hbWU6ICdEZWZhdWx0IFJ1bGUnLFxuXHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0dHlwZTogUnVsZVR5cGUuRm9sZGVyLFxuXHRcdHBhdGg6ICcnLCAvLyBNYXRjaGVzIGFsbCBmaWxlcyBieSBkZWZhdWx0XG5cdFx0cmVjdXJzaXZlOiB0cnVlLFxuXHRcdGNvbnRlbnRTb3VyY2U6IENvbnRlbnRTb3VyY2UuVGV4dCxcblx0XHRmb290ZXJUZXh0OiAnJywgLy8gRGVmYXVsdCBjb250ZW50IGlzIGVtcHR5XG5cdFx0cmVuZGVyTG9jYXRpb246IFJlbmRlckxvY2F0aW9uLkZvb3Rlcixcblx0fV0sXG5cdHJlZnJlc2hPbkZpbGVPcGVuOiBmYWxzZSwgLy8gRGVmYXVsdCB0byBmYWxzZVxufTtcblxuLy8gQ1NTIENsYXNzZXMgZm9yIHN0eWxpbmcgYW5kIGlkZW50aWZ5aW5nIHBsdWdpbi1nZW5lcmF0ZWQgZWxlbWVudHNcbmNvbnN0IENTU19EWU5BTUlDX0NPTlRFTlRfRUxFTUVOVCA9ICd2aXJ0dWFsLWZvb3Rlci1keW5hbWljLWNvbnRlbnQtZWxlbWVudCc7XG5jb25zdCBDU1NfSEVBREVSX0dST1VQX0VMRU1FTlQgPSAndmlydHVhbC1mb290ZXItaGVhZGVyLWdyb3VwJztcbmNvbnN0IENTU19GT09URVJfR1JPVVBfRUxFTUVOVCA9ICd2aXJ0dWFsLWZvb3Rlci1mb290ZXItZ3JvdXAnO1xuY29uc3QgQ1NTX0hFQURFUl9SRU5ERVJFRF9DT05URU5UID0gJ3ZpcnR1YWwtZm9vdGVyLWhlYWRlci1yZW5kZXJlZC1jb250ZW50JztcbmNvbnN0IENTU19GT09URVJfUkVOREVSRURfQ09OVEVOVCA9ICd2aXJ0dWFsLWZvb3Rlci1mb290ZXItcmVuZGVyZWQtY29udGVudCc7XG5jb25zdCBDU1NfVklSVFVBTF9GT09URVJfQ01fUEFERElORyA9ICd2aXJ0dWFsLWZvb3Rlci1jbS1wYWRkaW5nJzsgLy8gRm9yIENvZGVNaXJyb3IgbGl2ZSBwcmV2aWV3IGZvb3RlciBzcGFjaW5nXG5jb25zdCBDU1NfVklSVFVBTF9GT09URVJfUkVNT1ZFX0ZMRVggPSAndmlydHVhbC1mb290ZXItcmVtb3ZlLWZsZXgnOyAvLyBGb3IgQ29kZU1pcnJvciBsaXZlIHByZXZpZXcgZm9vdGVyIGxheW91dFxuXG4vLyBET00gU2VsZWN0b3JzIGZvciB0YXJnZXRpbmcgZWxlbWVudHMgaW4gT2JzaWRpYW4ncyBpbnRlcmZhY2VcbmNvbnN0IFNFTEVDVE9SX0VESVRPUl9DT05URU5UX0FSRUEgPSAnLmNtLWVkaXRvciAuY20tY29udGVudCc7XG5jb25zdCBTRUxFQ1RPUl9FRElUT1JfQ09OVEVOVF9DT05UQUlORVJfUEFSRU5UID0gJy5tYXJrZG93bi1zb3VyY2Utdmlldy5tb2QtY202IC5jbS1jb250ZW50Q29udGFpbmVyJztcbmNvbnN0IFNFTEVDVE9SX0xJVkVfUFJFVklFV19DT05URU5UX0NPTlRBSU5FUiA9ICcuY20tY29udGVudENvbnRhaW5lcic7XG5jb25zdCBTRUxFQ1RPUl9FRElUT1JfU0laRVIgPSAnLmNtLXNpemVyJzsgLy8gVGFyZ2V0IGZvciBsaXZlIHByZXZpZXcgZm9vdGVyIGluamVjdGlvblxuY29uc3QgU0VMRUNUT1JfUFJFVklFV19IRUFERVJfQVJFQSA9ICcubW9kLWhlYWRlci5tb2QtdWknOyAvLyBUYXJnZXQgZm9yIHJlYWRpbmcgbW9kZSBoZWFkZXIgaW5qZWN0aW9uXG5jb25zdCBTRUxFQ1RPUl9QUkVWSUVXX0ZPT1RFUl9BUkVBID0gJy5tb2QtZm9vdGVyJzsgLy8gVGFyZ2V0IGZvciByZWFkaW5nIG1vZGUgZm9vdGVyIGluamVjdGlvblxuXG4vLyAtLS0gVXRpbGl0eSBDbGFzc2VzIC0tLVxuXG4vKipcbiAqIEEgc3VnZ2VzdGlvbiBwcm92aWRlciBmb3IgaW5wdXQgZmllbGRzLCBvZmZlcmluZyBhdXRvY29tcGxldGlvbiBmcm9tIGEgZ2l2ZW4gc2V0IG9mIHN0cmluZ3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBNdWx0aVN1Z2dlc3QgZXh0ZW5kcyBBYnN0cmFjdElucHV0U3VnZ2VzdDxzdHJpbmc+IHtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgTXVsdGlTdWdnZXN0LlxuXHQgKiBAcGFyYW0gaW5wdXRFbCBUaGUgSFRNTCBpbnB1dCBlbGVtZW50IHRvIGF0dGFjaCB0aGUgc3VnZ2VzdGVyIHRvLlxuXHQgKiBAcGFyYW0gY29udGVudCBUaGUgc2V0IG9mIHN0cmluZ3MgdG8gdXNlIGFzIHN1Z2dlc3Rpb25zLlxuXHQgKiBAcGFyYW0gb25TZWxlY3RDYiBDYWxsYmFjayBmdW5jdGlvbiBleGVjdXRlZCB3aGVuIGEgc3VnZ2VzdGlvbiBpcyBzZWxlY3RlZC5cblx0ICogQHBhcmFtIGFwcCBUaGUgT2JzaWRpYW4gQXBwIGluc3RhbmNlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoXG5cdFx0cHJpdmF0ZSBpbnB1dEVsOiBIVE1MSW5wdXRFbGVtZW50LFxuXHRcdHByaXZhdGUgY29udGVudDogU2V0PHN0cmluZz4sXG5cdFx0cHJpdmF0ZSBvblNlbGVjdENiOiAodmFsdWU6IHN0cmluZykgPT4gdm9pZCxcblx0XHRhcHA6IEFwcFxuXHQpIHtcblx0XHRzdXBlcihhcHAsIGlucHV0RWwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZpbHRlcnMgdGhlIGNvbnRlbnQgc2V0IHRvIGZpbmQgc3VnZ2VzdGlvbnMgbWF0Y2hpbmcgdGhlIGlucHV0IHN0cmluZy5cblx0ICogQHBhcmFtIGlucHV0U3RyIFRoZSBjdXJyZW50IHN0cmluZyBpbiB0aGUgaW5wdXQgZmllbGQuXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG1hdGNoaW5nIHN1Z2dlc3Rpb24gc3RyaW5ncy5cblx0ICovXG5cdGdldFN1Z2dlc3Rpb25zKGlucHV0U3RyOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG5cdFx0Y29uc3QgbG93ZXJDYXNlSW5wdXRTdHIgPSBpbnB1dFN0ci50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBbLi4udGhpcy5jb250ZW50XS5maWx0ZXIoKGNvbnRlbnRJdGVtKSA9PlxuXHRcdFx0Y29udGVudEl0ZW0udG9Mb2NhbGVMb3dlckNhc2UoKS5pbmNsdWRlcyhsb3dlckNhc2VJbnB1dFN0cilcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbmRlcnMgYSBzaW5nbGUgc3VnZ2VzdGlvbiBpdGVtIGluIHRoZSBzdWdnZXN0aW9uIGxpc3QuXG5cdCAqIEBwYXJhbSBjb250ZW50IFRoZSBzdWdnZXN0aW9uIHN0cmluZyB0byByZW5kZXIuXG5cdCAqIEBwYXJhbSBlbCBUaGUgSFRNTEVsZW1lbnQgdG8gcmVuZGVyIHRoZSBzdWdnZXN0aW9uIGludG8uXG5cdCAqL1xuXHRyZW5kZXJTdWdnZXN0aW9uKGNvbnRlbnQ6IHN0cmluZywgZWw6IEhUTUxFbGVtZW50KTogdm9pZCB7XG5cdFx0ZWwuc2V0VGV4dChjb250ZW50KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIHRoZSBzZWxlY3Rpb24gb2YgYSBzdWdnZXN0aW9uLlxuXHQgKiBAcGFyYW0gY29udGVudCBUaGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbiBzdHJpbmcuXG5cdCAqIEBwYXJhbSBfZXZ0IFRoZSBtb3VzZSBvciBrZXlib2FyZCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgc2VsZWN0aW9uLlxuXHQgKi9cblx0c2VsZWN0U3VnZ2VzdGlvbihjb250ZW50OiBzdHJpbmcsIF9ldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cdFx0dGhpcy5vblNlbGVjdENiKGNvbnRlbnQpO1xuXHRcdHRoaXMuaW5wdXRFbC52YWx1ZSA9IGNvbnRlbnQ7IC8vIFVwZGF0ZSBpbnB1dCBmaWVsZCB3aXRoIHNlbGVjdGVkIHZhbHVlXG5cdFx0dGhpcy5pbnB1dEVsLmJsdXIoKTsgLy8gUmVtb3ZlIGZvY3VzIGZyb20gaW5wdXRcblx0XHR0aGlzLmNsb3NlKCk7IC8vIENsb3NlIHRoZSBzdWdnZXN0aW9uIHBvcG92ZXJcblx0fVxufVxuXG4vLyAtLS0gTWFpbiBQbHVnaW4gQ2xhc3MgLS0tXG5cbi8qKlxuICogVmlydHVhbEZvb3RlclBsdWdpbiBkeW5hbWljYWxseSBpbmplY3RzIGNvbnRlbnQgaW50byB0aGUgaGVhZGVyIG9yIGZvb3RlciBvZiBNYXJrZG93biB2aWV3c1xuICogYmFzZWQgb24gY29uZmlndXJhYmxlIHJ1bGVzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaXJ0dWFsRm9vdGVyUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcblx0c2V0dGluZ3M6IFZpcnR1YWxGb290ZXJTZXR0aW5ncztcblx0LyoqIFN0b3JlcyBwZW5kaW5nIGNvbnRlbnQgaW5qZWN0aW9ucyBmb3IgcHJldmlldyBtb2RlLCBhd2FpdGluZyBET00gYXZhaWxhYmlsaXR5LiAqL1xuXHRwcml2YXRlIHBlbmRpbmdQcmV2aWV3SW5qZWN0aW9uczogV2Vha01hcDxNYXJrZG93blZpZXcsIHsgaGVhZGVyRGl2PzogSFRNTEVsZW1lbnRXaXRoQ29tcG9uZW50LCBmb290ZXJEaXY/OiBIVE1MRWxlbWVudFdpdGhDb21wb25lbnQgfT4gPSBuZXcgV2Vha01hcCgpO1xuXHQvKiogTWFuYWdlcyBNdXRhdGlvbk9ic2VydmVycyBmb3Igdmlld3MgaW4gcHJldmlldyBtb2RlIHRvIGRldGVjdCB3aGVuIGluamVjdGlvbiB0YXJnZXRzIGFyZSByZWFkeS4gKi9cblx0cHJpdmF0ZSBwcmV2aWV3T2JzZXJ2ZXJzOiBXZWFrTWFwPE1hcmtkb3duVmlldywgTXV0YXRpb25PYnNlcnZlcj4gPSBuZXcgV2Vha01hcCgpO1xuXHRwcml2YXRlIGluaXRpYWxMYXlvdXRSZWFkeVByb2Nlc3NlZCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiB0aGUgcGx1Z2luIGlzIGxvYWRlZC5cblx0ICovXG5cdGFzeW5jIG9ubG9hZCgpIHtcblx0XHRhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuXHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgVmlydHVhbEZvb3RlclNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcblxuXHRcdC8vIERlZmluZSBldmVudCBoYW5kbGVyc1xuXHRcdGNvbnN0IGhhbmRsZUZpbGVPcGVuRXZlbnQgPSAoKSA9PiB7XG5cdFx0XHQvLyBPbmx5IHRyaWdnZXIgaWYgdGhlIHNldHRpbmcgaXMgZW5hYmxlZCBhbmQgaW5pdGlhbCBsYXlvdXQgaXMgcmVhZHlcblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLnJlZnJlc2hPbkZpbGVPcGVuICYmIHRoaXMuaW5pdGlhbExheW91dFJlYWR5UHJvY2Vzc2VkKSB7XG5cdFx0XHRcdHRoaXMuaGFuZGxlQWN0aXZlVmlld0NoYW5nZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRjb25zdCBoYW5kbGVMYXlvdXRDaGFuZ2VFdmVudCA9ICgpID0+IHtcblx0XHRcdC8vIEFsd2F5cyB0cmlnZ2VyIG9uIGxheW91dCBjaGFuZ2UgaWYgaW5pdGlhbCBsYXlvdXQgaXMgcmVhZHlcblx0XHRcdGlmICh0aGlzLmluaXRpYWxMYXlvdXRSZWFkeVByb2Nlc3NlZCkge1xuXHRcdFx0XHR0aGlzLmhhbmRsZUFjdGl2ZVZpZXdDaGFuZ2UoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gUmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzXG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50KFxuXHRcdFx0dGhpcy5hcHAud29ya3NwYWNlLm9uKCdmaWxlLW9wZW4nLCBoYW5kbGVGaWxlT3BlbkV2ZW50KVxuXHRcdCk7XG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50KFxuXHRcdFx0dGhpcy5hcHAud29ya3NwYWNlLm9uKCdsYXlvdXQtY2hhbmdlJywgaGFuZGxlTGF5b3V0Q2hhbmdlRXZlbnQpXG5cdFx0KTtcblxuXHRcdC8vIEluaXRpYWwgcHJvY2Vzc2luZyBmb3IgYW55IGN1cnJlbnRseSBhY3RpdmUgdmlldywgb25jZSBsYXlvdXQgaXMgcmVhZHlcblx0XHR0aGlzLmFwcC53b3Jrc3BhY2Uub25MYXlvdXRSZWFkeSgoKSA9PiB7XG5cdFx0XHRpZiAoIXRoaXMuaW5pdGlhbExheW91dFJlYWR5UHJvY2Vzc2VkKSB7XG5cdFx0XHRcdHRoaXMuaGFuZGxlQWN0aXZlVmlld0NoYW5nZSgpOyAvLyBQcm9jZXNzIHRoZSBpbml0aWFsbHkgb3BlbiB2aWV3XG5cdFx0XHRcdHRoaXMuaW5pdGlhbExheW91dFJlYWR5UHJvY2Vzc2VkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiB0aGUgcGx1Z2luIGlzIHVubG9hZGVkLlxuXHQgKiBDbGVhbnMgdXAgYWxsIGluamVjdGVkIGNvbnRlbnQgYW5kIG9ic2VydmVycy5cblx0ICovXG5cdGFzeW5jIG9udW5sb2FkKCkge1xuXHRcdHRoaXMuY2xlYXJBbGxWaWV3c0R5bmFtaWNDb250ZW50KCk7XG5cblx0XHQvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIERPTSBlbGVtZW50cyBhbmQgY29tcG9uZW50cyBkaXJlY3RseVxuXHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NTU19EWU5BTUlDX0NPTlRFTlRfRUxFTUVOVH1gKS5mb3JFYWNoKGVsID0+IHtcblx0XHRcdGNvbnN0IGNvbXBvbmVudEhvbGRlciA9IGVsIGFzIEhUTUxFbGVtZW50V2l0aENvbXBvbmVudDtcblx0XHRcdGlmIChjb21wb25lbnRIb2xkZXIuY29tcG9uZW50KSB7XG5cdFx0XHRcdGNvbXBvbmVudEhvbGRlci5jb21wb25lbnQudW5sb2FkKCk7XG5cdFx0XHR9XG5cdFx0XHRlbC5yZW1vdmUoKTtcblx0XHR9KTtcblxuXHRcdC8vIFJlbW92ZSBjdXN0b20gQ1NTIGNsYXNzZXMgYXBwbGllZCBmb3Igc3R5bGluZ1xuXHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NTU19WSVJUVUFMX0ZPT1RFUl9DTV9QQURESU5HfWApLmZvckVhY2goZWwgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZShDU1NfVklSVFVBTF9GT09URVJfQ01fUEFERElORykpO1xuXHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NTU19WSVJUVUFMX0ZPT1RFUl9SRU1PVkVfRkxFWH1gKS5mb3JFYWNoKGVsID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoQ1NTX1ZJUlRVQUxfRk9PVEVSX1JFTU9WRV9GTEVYKSk7XG5cblx0XHQvLyBXZWFrTWFwcyB3aWxsIGJlIGdhcmJhZ2UgY29sbGVjdGVkLCBidXQgZXhwbGljaXQgY2xlYXJpbmcgaXMgZ29vZCBwcmFjdGljZSBpZiBuZWVkZWQuXG5cdFx0Ly8gT2JzZXJ2ZXJzIGFuZCBwZW5kaW5nIGluamVjdGlvbnMgYXJlIGNsZWFyZWQgcGVyLXZpZXcgaW4gYHJlbW92ZUR5bmFtaWNDb250ZW50RnJvbVZpZXdgLlxuXHRcdHRoaXMucHJldmlld09ic2VydmVycyA9IG5ldyBXZWFrTWFwKCk7XG5cdFx0dGhpcy5wZW5kaW5nUHJldmlld0luamVjdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgY2hhbmdlcyB0byB0aGUgYWN0aXZlIE1hcmtkb3duIHZpZXcsIHRyaWdnZXJpbmcgY29udGVudCBwcm9jZXNzaW5nLlxuXHQgKi9cblx0cHJpdmF0ZSBoYW5kbGVBY3RpdmVWaWV3Q2hhbmdlID0gKCkgPT4ge1xuXHRcdGNvbnN0IGFjdGl2ZVZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xuXHRcdHRoaXMuX3Byb2Nlc3NWaWV3KGFjdGl2ZVZpZXcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb2Nlc3NlcyBhIGdpdmVuIE1hcmtkb3duIHZpZXcgdG8gaW5qZWN0IG9yIHVwZGF0ZSBkeW5hbWljIGNvbnRlbnQuXG5cdCAqIEBwYXJhbSB2aWV3IFRoZSBNYXJrZG93blZpZXcgdG8gcHJvY2Vzcy5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgX3Byb2Nlc3NWaWV3KHZpZXc6IE1hcmtkb3duVmlldyB8IG51bGwpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXZpZXcgfHwgIXZpZXcuZmlsZSkge1xuXHRcdFx0cmV0dXJuOyAvLyBObyB2aWV3IG9yIGZpbGUgdG8gcHJvY2Vzc1xuXHRcdH1cblxuXHRcdGF3YWl0IHRoaXMucmVtb3ZlRHluYW1pY0NvbnRlbnRGcm9tVmlldyh2aWV3KTsgLy8gQ2xlYXIgZXhpc3RpbmcgY29udGVudCBmaXJzdFxuXHRcdGNvbnN0IGFwcGxpY2FibGVSdWxlc1dpdGhDb250ZW50ID0gYXdhaXQgdGhpcy5fZ2V0QXBwbGljYWJsZVJ1bGVzQW5kQ29udGVudCh2aWV3LmZpbGUucGF0aCk7XG5cblx0XHRpZiAoYXBwbGljYWJsZVJ1bGVzV2l0aENvbnRlbnQubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm47IC8vIE5vIHJ1bGVzIGFwcGx5IHRvIHRoaXMgZmlsZVxuXHRcdH1cblxuXHRcdGNvbnN0IHZpZXdTdGF0ZSA9IHZpZXcuZ2V0U3RhdGUoKTtcblx0XHRsZXQgY29tYmluZWRIZWFkZXJUZXh0ID0gXCJcIjtcblx0XHRsZXQgY29tYmluZWRGb290ZXJUZXh0ID0gXCJcIjtcblx0XHRsZXQgaGFzRm9vdGVyUnVsZSA9IGZhbHNlO1xuXHRcdGNvbnN0IGNvbnRlbnRTZXBhcmF0b3IgPSBcIlxcblxcblwiOyAvLyBTZXBhcmF0b3IgYmV0d2VlbiBjb250ZW50IGZyb20gbXVsdGlwbGUgcnVsZXNcblxuXHRcdC8vIENvbWJpbmUgY29udGVudCBmcm9tIGFsbCBhcHBsaWNhYmxlIHJ1bGVzXG5cdFx0Zm9yIChjb25zdCB7IHJ1bGUsIGNvbnRlbnRUZXh0IH0gb2YgYXBwbGljYWJsZVJ1bGVzV2l0aENvbnRlbnQpIHtcblx0XHRcdGlmICghY29udGVudFRleHQgfHwgY29udGVudFRleHQudHJpbSgpID09PSBcIlwiKSBjb250aW51ZTsgLy8gU2tpcCBlbXB0eSBjb250ZW50XG5cblx0XHRcdGlmIChydWxlLnJlbmRlckxvY2F0aW9uID09PSBSZW5kZXJMb2NhdGlvbi5IZWFkZXIpIHtcblx0XHRcdFx0Y29tYmluZWRIZWFkZXJUZXh0ICs9IChjb21iaW5lZEhlYWRlclRleHQgPyBjb250ZW50U2VwYXJhdG9yIDogXCJcIikgKyBjb250ZW50VGV4dDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbWJpbmVkRm9vdGVyVGV4dCArPSAoY29tYmluZWRGb290ZXJUZXh0ID8gY29udGVudFNlcGFyYXRvciA6IFwiXCIpICsgY29udGVudFRleHQ7XG5cdFx0XHRcdGhhc0Zvb3RlclJ1bGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHNwZWNpZmljIHN0eWxlcyBmb3IgTGl2ZSBQcmV2aWV3IGZvb3RlcnMgaWYgbmVlZGVkXG5cdFx0aWYgKHZpZXdTdGF0ZS5tb2RlID09PSAnc291cmNlJyAmJiAhdmlld1N0YXRlLnNvdXJjZSAmJiBoYXNGb290ZXJSdWxlKSB7IC8vIExpdmUgUHJldmlldyBtb2RlXG5cdFx0XHR0aGlzLmFwcGx5TGl2ZVByZXZpZXdGb290ZXJTdHlsZXModmlldyk7XG5cdFx0fVxuXG5cdFx0bGV0IHBlbmRpbmdIZWFkZXJEaXY6IEhUTUxFbGVtZW50V2l0aENvbXBvbmVudCB8IG51bGwgPSBudWxsO1xuXHRcdGxldCBwZW5kaW5nRm9vdGVyRGl2OiBIVE1MRWxlbWVudFdpdGhDb21wb25lbnQgfCBudWxsID0gbnVsbDtcblxuXHRcdC8vIFJlbmRlciBhbmQgaW5qZWN0IGNvbnRlbnQgYmFzZWQgb24gdmlldyBtb2RlXG5cdFx0aWYgKHZpZXdTdGF0ZS5tb2RlID09PSAncHJldmlldycgfHwgKHZpZXdTdGF0ZS5tb2RlID09PSAnc291cmNlJyAmJiAhdmlld1N0YXRlLnNvdXJjZSkpIHsgLy8gUmVhZGluZyBvciBMaXZlIFByZXZpZXdcblx0XHRcdGlmIChjb21iaW5lZEhlYWRlclRleHQudHJpbSgpKSB7XG5cdFx0XHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVuZGVyQW5kSW5qZWN0R3JvdXBlZENvbnRlbnQodmlldywgY29tYmluZWRIZWFkZXJUZXh0LCBSZW5kZXJMb2NhdGlvbi5IZWFkZXIpO1xuXHRcdFx0XHQvLyBJZiBpbiBwcmV2aWV3IG1vZGUgYW5kIGluamVjdGlvbiBpcyBkZWZlcnJlZCwgc3RvcmUgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKHJlc3VsdCAmJiB2aWV3U3RhdGUubW9kZSA9PT0gJ3ByZXZpZXcnKSB7XG5cdFx0XHRcdFx0cGVuZGluZ0hlYWRlckRpdiA9IHJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbWJpbmVkRm9vdGVyVGV4dC50cmltKCkpIHtcblx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZW5kZXJBbmRJbmplY3RHcm91cGVkQ29udGVudCh2aWV3LCBjb21iaW5lZEZvb3RlclRleHQsIFJlbmRlckxvY2F0aW9uLkZvb3Rlcik7XG5cdFx0XHRcdGlmIChyZXN1bHQgJiYgdmlld1N0YXRlLm1vZGUgPT09ICdwcmV2aWV3Jykge1xuXHRcdFx0XHRcdHBlbmRpbmdGb290ZXJEaXYgPSByZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiBhbnkgY29udGVudCBpcyBwZW5kaW5nIGZvciBwcmV2aWV3IG1vZGUsIHNldCB1cCBhbiBvYnNlcnZlclxuXHRcdGlmIChwZW5kaW5nSGVhZGVyRGl2IHx8IHBlbmRpbmdGb290ZXJEaXYpIHtcblx0XHRcdGxldCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nUHJldmlld0luamVjdGlvbnMuZ2V0KHZpZXcpO1xuXHRcdFx0aWYgKCFwZW5kaW5nKSB7XG5cdFx0XHRcdHBlbmRpbmcgPSB7fTtcblx0XHRcdFx0dGhpcy5wZW5kaW5nUHJldmlld0luamVjdGlvbnMuc2V0KHZpZXcsIHBlbmRpbmcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBlbmRpbmdIZWFkZXJEaXYpIHBlbmRpbmcuaGVhZGVyRGl2ID0gcGVuZGluZ0hlYWRlckRpdjtcblx0XHRcdGlmIChwZW5kaW5nRm9vdGVyRGl2KSBwZW5kaW5nLmZvb3RlckRpdiA9IHBlbmRpbmdGb290ZXJEaXY7XG5cdFx0XHR0aGlzLmVuc3VyZVByZXZpZXdPYnNlcnZlcih2aWV3KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVycyBjb21iaW5lZCBNYXJrZG93biBjb250ZW50IGFuZCBpbmplY3RzIGl0IGludG8gdGhlIHNwZWNpZmllZCBsb2NhdGlvbiBpbiB0aGUgdmlldy5cblx0ICogQHBhcmFtIHZpZXcgVGhlIE1hcmtkb3duVmlldyB0byBpbmplY3QgY29udGVudCBpbnRvLlxuXHQgKiBAcGFyYW0gY29tYmluZWRDb250ZW50VGV4dCBUaGUgY29tYmluZWQgTWFya2Rvd24gc3RyaW5nIHRvIHJlbmRlci5cblx0ICogQHBhcmFtIHJlbmRlckxvY2F0aW9uIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJlbmRlciBpbiB0aGUgaGVhZGVyIG9yIGZvb3Rlci5cblx0ICogQHJldHVybnMgVGhlIHJlbmRlcmVkIEhUTUxFbGVtZW50IGlmIGluamVjdGlvbiBpcyBkZWZlcnJlZCAoZm9yIHByZXZpZXcgbW9kZSksIG90aGVyd2lzZSBudWxsLlxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyByZW5kZXJBbmRJbmplY3RHcm91cGVkQ29udGVudChcblx0XHR2aWV3OiBNYXJrZG93blZpZXcsXG5cdFx0Y29tYmluZWRDb250ZW50VGV4dDogc3RyaW5nLFxuXHRcdHJlbmRlckxvY2F0aW9uOiBSZW5kZXJMb2NhdGlvblxuXHQpOiBQcm9taXNlPEhUTUxFbGVtZW50V2l0aENvbXBvbmVudCB8IG51bGw+IHtcblx0XHRpZiAoIWNvbWJpbmVkQ29udGVudFRleHQgfHwgY29tYmluZWRDb250ZW50VGV4dC50cmltKCkgPT09IFwiXCIpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGNvbnN0IGlzUmVuZGVySW5IZWFkZXIgPSByZW5kZXJMb2NhdGlvbiA9PT0gUmVuZGVyTG9jYXRpb24uSGVhZGVyO1xuXHRcdGNvbnN0IHNvdXJjZVBhdGggPSB2aWV3LmZpbGU/LnBhdGggfHwgJyc7IC8vIEZvciBNYXJrZG93blJlbmRlcmVyIGNvbnRleHRcblxuXHRcdC8vIENyZWF0ZSBjb250YWluZXIgZGl2IGZvciB0aGUgY29udGVudFxuXHRcdGNvbnN0IGdyb3VwRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgYXMgSFRNTEVsZW1lbnRXaXRoQ29tcG9uZW50O1xuXHRcdGdyb3VwRGl2LmNsYXNzTmFtZSA9IENTU19EWU5BTUlDX0NPTlRFTlRfRUxFTUVOVDsgLy8gQmFzZSBjbGFzcyBmb3IgYWxsIGluamVjdGVkIGNvbnRlbnRcblx0XHRncm91cERpdi5jbGFzc0xpc3QuYWRkKFxuXHRcdFx0aXNSZW5kZXJJbkhlYWRlciA/IENTU19IRUFERVJfR1JPVVBfRUxFTUVOVCA6IENTU19GT09URVJfR1JPVVBfRUxFTUVOVCxcblx0XHRcdGlzUmVuZGVySW5IZWFkZXIgPyBDU1NfSEVBREVSX1JFTkRFUkVEX0NPTlRFTlQgOiBDU1NfRk9PVEVSX1JFTkRFUkVEX0NPTlRFTlRcblx0XHQpO1xuXG5cdFx0Ly8gQ3JlYXRlIGFuZCBtYW5hZ2UgYW4gT2JzaWRpYW4gQ29tcG9uZW50IGZvciB0aGUgbGlmZWN5Y2xlIG9mIHRoaXMgY29udGVudFxuXHRcdGNvbnN0IGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnQoKTtcblx0XHRjb21wb25lbnQubG9hZCgpO1xuXHRcdGdyb3VwRGl2LmNvbXBvbmVudCA9IGNvbXBvbmVudDtcblxuXHRcdC8vIFJlbmRlciBNYXJrZG93biBjb250ZW50XG5cdFx0YXdhaXQgTWFya2Rvd25SZW5kZXJlci5yZW5kZXIodGhpcy5hcHAsIGNvbWJpbmVkQ29udGVudFRleHQsIGdyb3VwRGl2LCBzb3VyY2VQYXRoLCBjb21wb25lbnQpO1xuXG5cdFx0bGV0IGluamVjdGlvblN1Y2Nlc3NmdWwgPSBmYWxzZTtcblx0XHRjb25zdCB2aWV3U3RhdGUgPSB2aWV3LmdldFN0YXRlKCk7XG5cblx0XHQvLyBJbmplY3QgYmFzZWQgb24gdmlldyBtb2RlIGFuZCByZW5kZXIgbG9jYXRpb25cblx0XHRpZiAodmlld1N0YXRlLm1vZGUgPT09ICdwcmV2aWV3JykgeyAvLyBSZWFkaW5nIG1vZGVcblx0XHRcdGNvbnN0IHByZXZpZXdDb250ZW50UGFyZW50ID0gdmlldy5wcmV2aWV3TW9kZS5jb250YWluZXJFbDtcblx0XHRcdGNvbnN0IHRhcmdldFBhcmVudCA9IHByZXZpZXdDb250ZW50UGFyZW50LnF1ZXJ5U2VsZWN0b3I8SFRNTEVsZW1lbnQ+KFxuXHRcdFx0XHRpc1JlbmRlckluSGVhZGVyID8gU0VMRUNUT1JfUFJFVklFV19IRUFERVJfQVJFQSA6IFNFTEVDVE9SX1BSRVZJRVdfRk9PVEVSX0FSRUFcblx0XHRcdCk7XG5cdFx0XHRpZiAodGFyZ2V0UGFyZW50KSB7XG5cdFx0XHRcdHRhcmdldFBhcmVudC5hcHBlbmRDaGlsZChncm91cERpdik7XG5cdFx0XHRcdGluamVjdGlvblN1Y2Nlc3NmdWwgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodmlld1N0YXRlLm1vZGUgPT09ICdzb3VyY2UnICYmICF2aWV3U3RhdGUuc291cmNlKSB7IC8vIExpdmUgUHJldmlldyBtb2RlXG5cdFx0XHRpZiAoaXNSZW5kZXJJbkhlYWRlcikge1xuXHRcdFx0XHRjb25zdCBjbUNvbnRlbnRDb250YWluZXIgPSB2aWV3LmNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3I8SFRNTEVsZW1lbnQ+KFNFTEVDVE9SX0xJVkVfUFJFVklFV19DT05URU5UX0NPTlRBSU5FUik7XG5cdFx0XHRcdGlmIChjbUNvbnRlbnRDb250YWluZXI/LnBhcmVudEVsZW1lbnQpIHtcblx0XHRcdFx0XHRjbUNvbnRlbnRDb250YWluZXIucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoZ3JvdXBEaXYsIGNtQ29udGVudENvbnRhaW5lcik7XG5cdFx0XHRcdFx0aW5qZWN0aW9uU3VjY2Vzc2Z1bCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7IC8vIEZvb3RlciBpbiBMaXZlIFByZXZpZXdcblx0XHRcdFx0Y29uc3QgdGFyZ2V0UGFyZW50ID0gdmlldy5jb250YWluZXJFbC5xdWVyeVNlbGVjdG9yPEhUTUxFbGVtZW50PihTRUxFQ1RPUl9FRElUT1JfU0laRVIpO1xuXHRcdFx0XHRpZiAodGFyZ2V0UGFyZW50KSB7XG5cdFx0XHRcdFx0dGFyZ2V0UGFyZW50LmFwcGVuZENoaWxkKGdyb3VwRGl2KTtcblx0XHRcdFx0XHRpbmplY3Rpb25TdWNjZXNzZnVsID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpbmplY3Rpb25TdWNjZXNzZnVsKSB7XG5cdFx0XHR0aGlzLmF0dGFjaEludGVybmFsTGlua0hhbmRsZXJzKGdyb3VwRGl2LCBzb3VyY2VQYXRoLCBjb21wb25lbnQpO1xuXHRcdFx0cmV0dXJuIG51bGw7IC8vIEluamVjdGlvbiBzdWNjZXNzZnVsLCBubyBuZWVkIHRvIHJldHVybiBlbGVtZW50XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIElmIGluamVjdGlvbiBmYWlsZWQgaW4gcHJldmlldyBtb2RlLCBpdCBtaWdodCBiZSBiZWNhdXNlIHRoZSB0YXJnZXQgRE9NIGlzbid0IHJlYWR5LlxuXHRcdFx0Ly8gUmV0dXJuIHRoZSBkaXYgdG8gYmUgaGFuZGxlZCBieSB0aGUgTXV0YXRpb25PYnNlcnZlci5cblx0XHRcdGlmICh2aWV3U3RhdGUubW9kZSA9PT0gJ3ByZXZpZXcnKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGBWaXJ0dWFsRm9vdGVyOiBEZWZlcnJpbmcgaW5qZWN0aW9uIGZvciAke3JlbmRlckxvY2F0aW9ufSBpbiBwcmV2aWV3IG1vZGUuIFRhcmdldCBub3QgZm91bmQgeWV0LmApO1xuXHRcdFx0XHRyZXR1cm4gZ3JvdXBEaXY7IC8vIFJldHVybiBmb3IgZGVmZXJyZWQgaW5qZWN0aW9uXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBGb3Igb3RoZXIgbW9kZXMsIGlmIGluamVjdGlvbiBmYWlscywgdW5sb2FkIGNvbXBvbmVudCBhbmQgbG9nIHdhcm5pbmcuXG5cdFx0XHRcdGNvbXBvbmVudC51bmxvYWQoKTtcblx0XHRcdFx0Y29uc29sZS53YXJuKGBWaXJ0dWFsRm9vdGVyOiBGYWlsZWQgdG8gZmluZCBpbmplY3Rpb24gcG9pbnQgZm9yIGR5bmFtaWMgY29udGVudCBncm91cCAoJHtyZW5kZXJMb2NhdGlvbn0pLiBWaWV3IG1vZGU6ICR7dmlld1N0YXRlLm1vZGV9LmApO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRW5zdXJlcyBhIE11dGF0aW9uT2JzZXJ2ZXIgaXMgc2V0IHVwIGZvciBhIHZpZXcgaW4gcHJldmlldyBtb2RlIHRvIGhhbmRsZSBkZWZlcnJlZCBjb250ZW50IGluamVjdGlvbi5cblx0ICogVGhlIG9ic2VydmVyIHdhdGNoZXMgZm9yIHRoZSBhcHBlYXJhbmNlIG9mIHRhcmdldCBET00gZWxlbWVudHMuXG5cdCAqIEBwYXJhbSB2aWV3IFRoZSBNYXJrZG93blZpZXcgdG8gb2JzZXJ2ZS5cblx0ICovXG5cdHByaXZhdGUgZW5zdXJlUHJldmlld09ic2VydmVyKHZpZXc6IE1hcmtkb3duVmlldyk6IHZvaWQge1xuXHRcdGlmICh0aGlzLnByZXZpZXdPYnNlcnZlcnMuaGFzKHZpZXcpIHx8ICF2aWV3LmZpbGUgfHwgIXZpZXcucHJldmlld01vZGU/LmNvbnRhaW5lckVsKSB7XG5cdFx0XHRyZXR1cm47IC8vIE9ic2VydmVyIGFscmVhZHkgZXhpc3RzLCBvciB2aWV3L2ZpbGUvY29udGFpbmVyIG5vdCByZWFkeVxuXHRcdH1cblxuXHRcdGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKF9tdXRhdGlvbnMpID0+IHtcblx0XHRcdC8vIElmIHRoZSB2aWV3IG9yIGZpbGUgaXMgbm8gbG9uZ2VyIHZhbGlkLCBkaXNjb25uZWN0IGFuZCBjbGVhbiB1cFxuXHRcdFx0aWYgKCF2aWV3LmZpbGUpIHtcblx0XHRcdFx0b2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXHRcdFx0XHR0aGlzLnByZXZpZXdPYnNlcnZlcnMuZGVsZXRlKHZpZXcpO1xuXHRcdFx0XHRjb25zdCBwZW5kaW5nU3RhbGUgPSB0aGlzLnBlbmRpbmdQcmV2aWV3SW5qZWN0aW9ucy5nZXQodmlldyk7XG5cdFx0XHRcdGlmIChwZW5kaW5nU3RhbGUpIHtcblx0XHRcdFx0XHRwZW5kaW5nU3RhbGUuaGVhZGVyRGl2Py5jb21wb25lbnQ/LnVubG9hZCgpO1xuXHRcdFx0XHRcdHBlbmRpbmdTdGFsZS5mb290ZXJEaXY/LmNvbXBvbmVudD8udW5sb2FkKCk7XG5cdFx0XHRcdFx0dGhpcy5wZW5kaW5nUHJldmlld0luamVjdGlvbnMuZGVsZXRlKHZpZXcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcGVuZGluZyA9IHRoaXMucGVuZGluZ1ByZXZpZXdJbmplY3Rpb25zLmdldCh2aWV3KTtcblx0XHRcdC8vIElmIG5vIHBlbmRpbmcgaW5qZWN0aW9ucywgZGlzY29ubmVjdFxuXHRcdFx0aWYgKCFwZW5kaW5nIHx8ICghcGVuZGluZy5oZWFkZXJEaXYgJiYgIXBlbmRpbmcuZm9vdGVyRGl2KSkge1xuXHRcdFx0XHRvYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cdFx0XHRcdHRoaXMucHJldmlld09ic2VydmVycy5kZWxldGUodmlldyk7XG5cdFx0XHRcdGlmIChwZW5kaW5nKSB0aGlzLnBlbmRpbmdQcmV2aWV3SW5qZWN0aW9ucy5kZWxldGUodmlldyk7IC8vIENsZWFuIHVwIGVudHJ5IGlmIGl0IGV4aXN0c1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGxldCBhbGxSZXNvbHZlZCA9IHRydWU7XG5cdFx0XHRjb25zdCBzb3VyY2VQYXRoID0gdmlldy5maWxlLnBhdGg7XG5cblx0XHRcdC8vIEF0dGVtcHQgdG8gaW5qZWN0IHBlbmRpbmcgaGVhZGVyIGNvbnRlbnRcblx0XHRcdGlmIChwZW5kaW5nLmhlYWRlckRpdikge1xuXHRcdFx0XHRjb25zdCBoZWFkZXJUYXJnZXRQYXJlbnQgPSB2aWV3LnByZXZpZXdNb2RlLmNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3I8SFRNTEVsZW1lbnQ+KFNFTEVDVE9SX1BSRVZJRVdfSEVBREVSX0FSRUEpO1xuXHRcdFx0XHRpZiAoaGVhZGVyVGFyZ2V0UGFyZW50KSB7XG5cdFx0XHRcdFx0aGVhZGVyVGFyZ2V0UGFyZW50LmFwcGVuZENoaWxkKHBlbmRpbmcuaGVhZGVyRGl2KTtcblx0XHRcdFx0XHRpZiAocGVuZGluZy5oZWFkZXJEaXYuY29tcG9uZW50KSB7XG5cdFx0XHRcdFx0XHR0aGlzLmF0dGFjaEludGVybmFsTGlua0hhbmRsZXJzKHBlbmRpbmcuaGVhZGVyRGl2LCBzb3VyY2VQYXRoLCBwZW5kaW5nLmhlYWRlckRpdi5jb21wb25lbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZWxldGUgcGVuZGluZy5oZWFkZXJEaXY7IC8vIEluamVjdGlvbiBzdWNjZXNzZnVsXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YWxsUmVzb2x2ZWQgPSBmYWxzZTsgLy8gVGFyZ2V0IG5vdCB5ZXQgYXZhaWxhYmxlXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQXR0ZW1wdCB0byBpbmplY3QgcGVuZGluZyBmb290ZXIgY29udGVudFxuXHRcdFx0aWYgKHBlbmRpbmcuZm9vdGVyRGl2KSB7XG5cdFx0XHRcdGNvbnN0IGZvb3RlclRhcmdldFBhcmVudCA9IHZpZXcucHJldmlld01vZGUuY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcjxIVE1MRWxlbWVudD4oU0VMRUNUT1JfUFJFVklFV19GT09URVJfQVJFQSk7XG5cdFx0XHRcdGlmIChmb290ZXJUYXJnZXRQYXJlbnQpIHtcblx0XHRcdFx0XHRmb290ZXJUYXJnZXRQYXJlbnQuYXBwZW5kQ2hpbGQocGVuZGluZy5mb290ZXJEaXYpO1xuXHRcdFx0XHRcdGlmIChwZW5kaW5nLmZvb3RlckRpdi5jb21wb25lbnQpIHtcblx0XHRcdFx0XHRcdHRoaXMuYXR0YWNoSW50ZXJuYWxMaW5rSGFuZGxlcnMocGVuZGluZy5mb290ZXJEaXYsIHNvdXJjZVBhdGgsIHBlbmRpbmcuZm9vdGVyRGl2LmNvbXBvbmVudCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRlbGV0ZSBwZW5kaW5nLmZvb3RlckRpdjsgLy8gSW5qZWN0aW9uIHN1Y2Nlc3NmdWxcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhbGxSZXNvbHZlZCA9IGZhbHNlOyAvLyBUYXJnZXQgbm90IHlldCBhdmFpbGFibGVcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhbGwgcGVuZGluZyBpbmplY3Rpb25zIGFyZSByZXNvbHZlZCwgZGlzY29ubmVjdCB0aGUgb2JzZXJ2ZXJcblx0XHRcdGlmIChhbGxSZXNvbHZlZCkge1xuXHRcdFx0XHRvYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cdFx0XHRcdHRoaXMucHJldmlld09ic2VydmVycy5kZWxldGUodmlldyk7XG5cdFx0XHRcdHRoaXMucGVuZGluZ1ByZXZpZXdJbmplY3Rpb25zLmRlbGV0ZSh2aWV3KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIFN0YXJ0IG9ic2VydmluZyB0aGUgcHJldmlldyBjb250YWluZXIgZm9yIGNoaWxkIGFuZCBzdWJ0cmVlIGNoYW5nZXNcblx0XHRvYnNlcnZlci5vYnNlcnZlKHZpZXcucHJldmlld01vZGUuY29udGFpbmVyRWwsIHsgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuXHRcdHRoaXMucHJldmlld09ic2VydmVycy5zZXQodmlldywgb2JzZXJ2ZXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgQ1NTIGNsYXNzZXMgdG8gYWRqdXN0IENvZGVNaXJyb3IgKExpdmUgUHJldmlldykgbGF5b3V0IGZvciBmb290ZXIgY29udGVudC5cblx0ICogQHBhcmFtIHZpZXcgVGhlIE1hcmtkb3duVmlldyBpbiBMaXZlIFByZXZpZXcgbW9kZS5cblx0ICovXG5cdHByaXZhdGUgYXBwbHlMaXZlUHJldmlld0Zvb3RlclN0eWxlcyh2aWV3OiBNYXJrZG93blZpZXcpOiB2b2lkIHtcblx0XHRjb25zdCBjb250ZW50RWwgPSB2aWV3LmNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3I8SFRNTERpdkVsZW1lbnQ+KFNFTEVDVE9SX0VESVRPUl9DT05URU5UX0FSRUEpO1xuXHRcdGNvbnN0IGNvbnRhaW5lckVsID0gdmlldy5jb250YWluZXJFbC5xdWVyeVNlbGVjdG9yPEhUTUxEaXZFbGVtZW50PihTRUxFQ1RPUl9FRElUT1JfQ09OVEVOVF9DT05UQUlORVJfUEFSRU5UKTtcblx0XHRjb250ZW50RWw/LmNsYXNzTGlzdC5hZGQoQ1NTX1ZJUlRVQUxfRk9PVEVSX0NNX1BBRERJTkcpO1xuXHRcdGNvbnRhaW5lckVsPy5jbGFzc0xpc3QuYWRkKENTU19WSVJUVUFMX0ZPT1RFUl9SRU1PVkVfRkxFWCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBDU1MgY2xhc3NlcyB1c2VkIGZvciBMaXZlIFByZXZpZXcgZm9vdGVyIGxheW91dCBhZGp1c3RtZW50cy5cblx0ICogQHBhcmFtIHZpZXdPckNvbnRhaW5lciBUaGUgTWFya2Rvd25WaWV3IG9yIGEgc3BlY2lmaWMgSFRNTEVsZW1lbnQgY29udGFpbmVyLlxuXHQgKi9cblx0cHJpdmF0ZSByZW1vdmVMaXZlUHJldmlld0Zvb3RlclN0eWxlcyh2aWV3T3JDb250YWluZXI6IE1hcmtkb3duVmlldyB8IEhUTUxFbGVtZW50KTogdm9pZCB7XG5cdFx0Y29uc3QgY29udGFpbmVyID0gdmlld09yQ29udGFpbmVyIGluc3RhbmNlb2YgTWFya2Rvd25WaWV3ID8gdmlld09yQ29udGFpbmVyLmNvbnRhaW5lckVsIDogdmlld09yQ29udGFpbmVyO1xuXHRcdGNvbnN0IGNvbnRlbnRFbCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yPEhUTUxEaXZFbGVtZW50PihTRUxFQ1RPUl9FRElUT1JfQ09OVEVOVF9BUkVBKTtcblx0XHRjb25zdCBjb250YWluZXJFbCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yPEhUTUxEaXZFbGVtZW50PihTRUxFQ1RPUl9FRElUT1JfQ09OVEVOVF9DT05UQUlORVJfUEFSRU5UKTtcblx0XHRjb250ZW50RWw/LmNsYXNzTGlzdC5yZW1vdmUoQ1NTX1ZJUlRVQUxfRk9PVEVSX0NNX1BBRERJTkcpO1xuXHRcdGNvbnRhaW5lckVsPy5jbGFzc0xpc3QucmVtb3ZlKENTU19WSVJUVUFMX0ZPT1RFUl9SRU1PVkVfRkxFWCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgcGx1Z2luLWluamVjdGVkIERPTSBlbGVtZW50cyBmcm9tIGEgZ2l2ZW4gY29udGFpbmVyLlxuXHQgKiBAcGFyYW0gY29udGFpbmVyRWwgVGhlIEhUTUxFbGVtZW50IHRvIHNlYXJjaCB3aXRoaW4uXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIHJlbW92ZUluamVjdGVkQ29udGVudERPTShjb250YWluZXJFbDogSFRNTEVsZW1lbnQpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDU1NfRFlOQU1JQ19DT05URU5UX0VMRU1FTlR9YCkuZm9yRWFjaChlbCA9PiB7XG5cdFx0XHRjb25zdCBjb21wb25lbnRIb2xkZXIgPSBlbCBhcyBIVE1MRWxlbWVudFdpdGhDb21wb25lbnQ7XG5cdFx0XHRpZiAoY29tcG9uZW50SG9sZGVyLmNvbXBvbmVudCkge1xuXHRcdFx0XHRjb21wb25lbnRIb2xkZXIuY29tcG9uZW50LnVubG9hZCgpOyAvLyBVbmxvYWQgYXNzb2NpYXRlZCBPYnNpZGlhbiBjb21wb25lbnRcblx0XHRcdH1cblx0XHRcdGVsLnJlbW92ZSgpOyAvLyBSZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSBET01cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCBkeW5hbWljIGNvbnRlbnQsIHN0eWxlcywgYW5kIG9ic2VydmVycyBhc3NvY2lhdGVkIHdpdGggYSBzcGVjaWZpYyB2aWV3LlxuXHQgKiBAcGFyYW0gdmlldyBUaGUgTWFya2Rvd25WaWV3IHRvIGNsZWFuIHVwLlxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyByZW1vdmVEeW5hbWljQ29udGVudEZyb21WaWV3KHZpZXc6IE1hcmtkb3duVmlldyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRoaXMucmVtb3ZlTGl2ZVByZXZpZXdGb290ZXJTdHlsZXModmlldyk7XG5cdFx0YXdhaXQgdGhpcy5yZW1vdmVJbmplY3RlZENvbnRlbnRET00odmlldy5jb250YWluZXJFbCk7XG5cblx0XHQvLyBEaXNjb25uZWN0IGFuZCByZW1vdmUgb2JzZXJ2ZXIgZm9yIHRoaXMgdmlld1xuXHRcdGNvbnN0IG9ic2VydmVyID0gdGhpcy5wcmV2aWV3T2JzZXJ2ZXJzLmdldCh2aWV3KTtcblx0XHRpZiAob2JzZXJ2ZXIpIHtcblx0XHRcdG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblx0XHRcdHRoaXMucHJldmlld09ic2VydmVycy5kZWxldGUodmlldyk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2xlYW4gdXAgYW55IHBlbmRpbmcgaW5qZWN0aW9ucyBmb3IgdGhpcyB2aWV3XG5cdFx0Y29uc3QgcGVuZGluZyA9IHRoaXMucGVuZGluZ1ByZXZpZXdJbmplY3Rpb25zLmdldCh2aWV3KTtcblx0XHRpZiAocGVuZGluZykge1xuXHRcdFx0cGVuZGluZy5oZWFkZXJEaXY/LmNvbXBvbmVudD8udW5sb2FkKCk7XG5cdFx0XHRwZW5kaW5nLmZvb3RlckRpdj8uY29tcG9uZW50Py51bmxvYWQoKTtcblx0XHRcdHRoaXMucGVuZGluZ1ByZXZpZXdJbmplY3Rpb25zLmRlbGV0ZSh2aWV3KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIGR5bmFtaWMgY29udGVudCBmcm9tIGFsbCBjdXJyZW50bHkgb3BlbiBNYXJrZG93biB2aWV3cy5cblx0ICogVHlwaWNhbGx5IHVzZWQgZHVyaW5nIHBsdWdpbiB1bmxvYWQgb3Igd2hlbiBnbG9iYWwgc2V0dGluZ3MgY2hhbmdlIHNpZ25pZmljYW50bHkuXG5cdCAqL1xuXHRwcml2YXRlIGNsZWFyQWxsVmlld3NEeW5hbWljQ29udGVudCgpOiB2b2lkIHtcblx0XHR0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKCdtYXJrZG93bicpLmZvckVhY2gobGVhZiA9PiB7XG5cdFx0XHRpZiAobGVhZi52aWV3IGluc3RhbmNlb2YgTWFya2Rvd25WaWV3KSB7XG5cdFx0XHRcdHRoaXMucmVtb3ZlRHluYW1pY0NvbnRlbnRGcm9tVmlldyhsZWFmLnZpZXcpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIERldGVybWluZXMgd2hpY2ggcnVsZXMgYXBwbHkgdG8gYSBnaXZlbiBmaWxlIHBhdGggYW5kIGZldGNoZXMgdGhlaXIgY29udGVudC5cblx0ICogQHBhcmFtIGZpbGVQYXRoIFRoZSBwYXRoIG9mIHRoZSBmaWxlIHRvIGNoZWNrIGFnYWluc3QgcnVsZXMuXG5cdCAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggY29udGFpbmluZyBhbiBhcHBsaWNhYmxlIHJ1bGUgYW5kIGl0cyBjb250ZW50LlxuXHQgKi9cblx0cHJpdmF0ZSBhc3luYyBfZ2V0QXBwbGljYWJsZVJ1bGVzQW5kQ29udGVudChmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTxBcnJheTx7IHJ1bGU6IFJ1bGU7IGNvbnRlbnRUZXh0OiBzdHJpbmcgfT4+IHtcblx0XHRjb25zdCBhbGxBcHBsaWNhYmxlOiBBcnJheTx7IHJ1bGU6IFJ1bGU7IGNvbnRlbnRUZXh0OiBzdHJpbmcgfT4gPSBbXTtcblx0XHRjb25zdCBhYnN0cmFjdEZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZVBhdGgpO1xuXG5cdFx0aWYgKCEoYWJzdHJhY3RGaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG5cdFx0XHRyZXR1cm4gW107IC8vIE5vdCBhIHZhbGlkIGZpbGVcblx0XHR9XG5cdFx0Y29uc3QgZmlsZTogVEZpbGUgPSBhYnN0cmFjdEZpbGU7XG5cdFx0bGV0IGZpbGVUYWdzOiBzdHJpbmdbXSB8IG51bGwgPSBudWxsOyAvLyBMYXppbHkgbG9hZGVkXG5cdFx0Y29uc3QgZmlsZUNhY2hlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XG5cblx0XHQvLyBQcmUtZmV0Y2ggdGFncyBpZiBhbnkgdGFnLWJhc2VkIHJ1bGVzIGV4aXN0IGFuZCBhcmUgZW5hYmxlZFxuXHRcdGNvbnN0IGhhc0VuYWJsZWRUYWdSdWxlID0gdGhpcy5zZXR0aW5ncy5ydWxlcy5zb21lKHIgPT4gci5lbmFibGVkICYmIHIudHlwZSA9PT0gUnVsZVR5cGUuVGFnKTtcblx0XHRpZiAoaGFzRW5hYmxlZFRhZ1J1bGUgJiYgZmlsZUNhY2hlKSB7XG5cdFx0XHRjb25zdCBhbGxUYWdzSW5GaWxlV2l0aEhhc2ggPSBnZXRBbGxUYWdzKGZpbGVDYWNoZSk7XG5cdFx0XHRmaWxlVGFncyA9IGFsbFRhZ3NJbkZpbGVXaXRoSGFzaCA/IGFsbFRhZ3NJbkZpbGVXaXRoSGFzaC5tYXAodGFnID0+IHRhZy5zdWJzdHJpbmcoMSkpIDogW107XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBjdXJyZW50UnVsZSBvZiB0aGlzLnNldHRpbmdzLnJ1bGVzKSB7XG5cdFx0XHRpZiAoIWN1cnJlbnRSdWxlLmVuYWJsZWQpIHtcblx0XHRcdFx0Y29udGludWU7IC8vIFNraXAgZGlzYWJsZWQgcnVsZXNcblx0XHRcdH1cblxuXHRcdFx0bGV0IGlzTWF0Y2ggPSBmYWxzZTtcblx0XHRcdGNvbnN0IHJ1bGVSZWN1cnNpdmUgPSBjdXJyZW50UnVsZS5yZWN1cnNpdmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjdXJyZW50UnVsZS5yZWN1cnNpdmU7XG5cblx0XHRcdC8vIC0tLSBNYXRjaCBieSBGb2xkZXIgLS0tXG5cdFx0XHRpZiAoY3VycmVudFJ1bGUudHlwZSA9PT0gUnVsZVR5cGUuRm9sZGVyICYmIGN1cnJlbnRSdWxlLnBhdGggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAoY3VycmVudFJ1bGUucGF0aCA9PT0gXCJcIikgeyAvLyBNYXRjaGVzIGFsbCBmaWxlc1xuXHRcdFx0XHRcdGlzTWF0Y2ggPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRSdWxlLnBhdGggPT09IFwiL1wiKSB7IC8vIE1hdGNoZXMgcm9vdCBmb2xkZXJcblx0XHRcdFx0XHRpc01hdGNoID0gcnVsZVJlY3Vyc2l2ZSA/IHRydWUgOiAoZmlsZS5wYXJlbnQ/LmlzUm9vdCgpID8/IGZhbHNlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsZXQgbm9ybWFsaXplZFJ1bGVGb2xkZXJQYXRoID0gY3VycmVudFJ1bGUucGF0aC5lbmRzV2l0aCgnLycpID8gY3VycmVudFJ1bGUucGF0aC5zbGljZSgwLCAtMSkgOiBjdXJyZW50UnVsZS5wYXRoO1xuXHRcdFx0XHRcdGlmIChydWxlUmVjdXJzaXZlKSB7XG5cdFx0XHRcdFx0XHRpc01hdGNoID0gZmlsZS5wYXRoLnN0YXJ0c1dpdGgobm9ybWFsaXplZFJ1bGVGb2xkZXJQYXRoICsgJy8nKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aXNNYXRjaCA9IGZpbGUucGFyZW50Py5wYXRoID09PSBub3JtYWxpemVkUnVsZUZvbGRlclBhdGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQvLyAtLS0gTWF0Y2ggYnkgVGFnIC0tLVxuXHRcdFx0fSBlbHNlIGlmIChjdXJyZW50UnVsZS50eXBlID09PSBSdWxlVHlwZS5UYWcgJiYgY3VycmVudFJ1bGUudGFnICYmIGZpbGVUYWdzKSB7XG5cdFx0XHRcdGNvbnN0IHJ1bGVUYWcgPSBjdXJyZW50UnVsZS50YWc7XG5cdFx0XHRcdGNvbnN0IGluY2x1ZGVTdWJ0YWdzID0gY3VycmVudFJ1bGUuaW5jbHVkZVN1YnRhZ3MgPz8gZmFsc2U7XG5cdFx0XHRcdGZvciAoY29uc3QgZmlsZVRhZyBvZiBmaWxlVGFncykge1xuXHRcdFx0XHRcdGlmIChpbmNsdWRlU3VidGFncykge1xuXHRcdFx0XHRcdFx0aWYgKGZpbGVUYWcgPT09IHJ1bGVUYWcgfHwgZmlsZVRhZy5zdGFydHNXaXRoKHJ1bGVUYWcgKyAnLycpKSB7XG5cdFx0XHRcdFx0XHRcdGlzTWF0Y2ggPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKGZpbGVUYWcgPT09IHJ1bGVUYWcpIHtcblx0XHRcdFx0XHRcdFx0aXNNYXRjaCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0Ly8gLS0tIE1hdGNoIGJ5IFByb3BlcnR5IC0tLVxuXHRcdFx0fSBlbHNlIGlmIChjdXJyZW50UnVsZS50eXBlID09PSBSdWxlVHlwZS5Qcm9wZXJ0eSAmJiBjdXJyZW50UnVsZS5wcm9wZXJ0eU5hbWUgJiYgZmlsZUNhY2hlPy5mcm9udG1hdHRlcikge1xuXHRcdFx0XHRjb25zdCBwcm9wZXJ0eUtleSA9IGN1cnJlbnRSdWxlLnByb3BlcnR5TmFtZTtcblx0XHRcdFx0Y29uc3QgZXhwZWN0ZWRQcm9wZXJ0eVZhbHVlID0gY3VycmVudFJ1bGUucHJvcGVydHlWYWx1ZTtcblx0XHRcdFx0Y29uc3QgYWN0dWFsUHJvcGVydHlWYWx1ZSA9IGZpbGVDYWNoZS5mcm9udG1hdHRlcltwcm9wZXJ0eUtleV07XG5cblx0XHRcdFx0aWYgKGFjdHVhbFByb3BlcnR5VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBhY3R1YWxQcm9wZXJ0eVZhbHVlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBhY3R1YWxQcm9wZXJ0eVZhbHVlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0aXNNYXRjaCA9IGFjdHVhbFByb3BlcnR5VmFsdWUgPT09IGV4cGVjdGVkUHJvcGVydHlWYWx1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYWN0dWFsUHJvcGVydHlWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdC8vIEZvciBhcnJheXMsIGNoZWNrIGlmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBvbmUgb2YgdGhlIGl0ZW1zXG5cdFx0XHRcdFx0XHRpc01hdGNoID0gYWN0dWFsUHJvcGVydHlWYWx1ZS5tYXAoU3RyaW5nKS5pbmNsdWRlcyhleHBlY3RlZFByb3BlcnR5VmFsdWUhKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBhY3R1YWxQcm9wZXJ0eVZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgYWN0dWFsUHJvcGVydHlWYWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdFx0XHRpc01hdGNoID0gU3RyaW5nKGFjdHVhbFByb3BlcnR5VmFsdWUpID09PSBleHBlY3RlZFByb3BlcnR5VmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc01hdGNoKSB7XG5cdFx0XHRcdGNvbnN0IGNvbnRlbnRUZXh0ID0gYXdhaXQgdGhpcy5fZmV0Y2hDb250ZW50Rm9yUnVsZShjdXJyZW50UnVsZSk7XG5cdFx0XHRcdGFsbEFwcGxpY2FibGUucHVzaCh7IHJ1bGU6IGN1cnJlbnRSdWxlLCBjb250ZW50VGV4dCB9KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGFsbEFwcGxpY2FibGU7XG5cdH1cblxuXHQvKipcblx0ICogRmV0Y2hlcyB0aGUgY29udGVudCBmb3IgYSBnaXZlbiBydWxlLCBlaXRoZXIgZnJvbSBkaXJlY3QgdGV4dCBvciBmcm9tIGEgc3BlY2lmaWVkIGZpbGUuXG5cdCAqIEBwYXJhbSBydWxlIFRoZSBydWxlIGZvciB3aGljaCB0byBmZXRjaCBjb250ZW50LlxuXHQgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgY29udGVudCBzdHJpbmcuXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIF9mZXRjaENvbnRlbnRGb3JSdWxlKHJ1bGU6IFJ1bGUpOiBQcm9taXNlPHN0cmluZz4ge1xuXHRcdGlmIChydWxlLmNvbnRlbnRTb3VyY2UgPT09IENvbnRlbnRTb3VyY2UuRmlsZSAmJiBydWxlLmZvb3RlckZpbGVQYXRoKSB7XG5cdFx0XHRjb25zdCBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHJ1bGUuZm9vdGVyRmlsZVBhdGgpO1xuXHRcdFx0aWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJldHVybiBhd2FpdCB0aGlzLmFwcC52YXVsdC5jYWNoZWRSZWFkKGZpbGUpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoYFZpcnR1YWxGb290ZXI6IEVycm9yIHJlYWRpbmcgY29udGVudCBmaWxlICR7cnVsZS5mb290ZXJGaWxlUGF0aH1gLCBlcnJvcik7XG5cdFx0XHRcdFx0cmV0dXJuIGA8IS0tIEVycm9yIHJlYWRpbmcgY29udGVudCBmaWxlOiAke3J1bGUuZm9vdGVyRmlsZVBhdGh9IC0tPmA7IC8vIFJldHVybiBlcnJvciBtZXNzYWdlIGluIGNvbnRlbnRcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKGBWaXJ0dWFsRm9vdGVyOiBDb250ZW50IGZpbGUgbm90IGZvdW5kIGZvciBydWxlOiAke3J1bGUuZm9vdGVyRmlsZVBhdGh9YCk7XG5cdFx0XHRcdHJldHVybiBgPCEtLSBDb250ZW50IGZpbGUgbm90IGZvdW5kOiAke3J1bGUuZm9vdGVyRmlsZVBhdGh9IC0tPmA7IC8vIFJldHVybiB3YXJuaW5nIGluIGNvbnRlbnRcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJ1bGUuZm9vdGVyVGV4dCB8fCBcIlwiOyAvLyBVc2UgZGlyZWN0IHRleHQgb3IgZW1wdHkgc3RyaW5nIGlmIG5vdCBmaWxlXG5cdH1cblxuXHQvKipcblx0ICogQXR0YWNoZXMgZXZlbnQgaGFuZGxlcnMgdG8gdGhlIGluamVjdGVkIGNvbnRlbnQgZm9yIGludGVybmFsIGxpbmsgbmF2aWdhdGlvbi5cblx0ICogQHBhcmFtIGNvbnRhaW5lciBUaGUgSFRNTEVsZW1lbnQgY29udGFpbmluZyB0aGUgcmVuZGVyZWQgTWFya2Rvd24uXG5cdCAqIEBwYXJhbSBzb3VyY2VQYXRoIFRoZSBwYXRoIG9mIHRoZSBmaWxlIHdoZXJlIHRoZSBjb250ZW50IGlzIGluamVjdGVkLCBmb3IgbGluayByZXNvbHV0aW9uLlxuXHQgKiBAcGFyYW0gY29tcG9uZW50IFRoZSBPYnNpZGlhbiBDb21wb25lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29udGVudCwgZm9yIGV2ZW50IHJlZ2lzdHJhdGlvbi5cblx0ICovXG5cdHByaXZhdGUgYXR0YWNoSW50ZXJuYWxMaW5rSGFuZGxlcnMoY29udGFpbmVyOiBIVE1MRWxlbWVudCwgc291cmNlUGF0aDogc3RyaW5nLCBjb21wb25lbnQ6IENvbXBvbmVudCk6IHZvaWQge1xuXHRcdC8vIEhhbmRsZSBsZWZ0LWNsaWNrIG9uIGludGVybmFsIGxpbmtzXG5cdFx0Y29tcG9uZW50LnJlZ2lzdGVyRG9tRXZlbnQoY29udGFpbmVyLCAnY2xpY2snLCAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcblx0XHRcdGlmIChldmVudC5idXR0b24gIT09IDApIHJldHVybjsgLy8gT25seSBoYW5kbGUgbGVmdC1jbGlja3Ncblx0XHRcdGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudDtcblx0XHRcdGNvbnN0IGxpbmtFbGVtZW50ID0gdGFyZ2V0LmNsb3Nlc3QoJ2EuaW50ZXJuYWwtbGluaycpIGFzIEhUTUxBbmNob3JFbGVtZW50O1xuXHRcdFx0aWYgKGxpbmtFbGVtZW50KSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgZGVmYXVsdCBsaW5rIG5hdmlnYXRpb25cblx0XHRcdFx0Y29uc3QgaHJlZiA9IGxpbmtFbGVtZW50LmRhdGFzZXQuaHJlZjtcblx0XHRcdFx0aWYgKGhyZWYpIHtcblx0XHRcdFx0XHRjb25zdCBpbk5ld1BhbmUgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7IC8vIE9wZW4gaW4gbmV3IHBhbmUgaWYgQ3RybC9DbWQgaXMgcHJlc3NlZFxuXHRcdFx0XHRcdHRoaXMuYXBwLndvcmtzcGFjZS5vcGVuTGlua1RleHQoaHJlZiwgc291cmNlUGF0aCwgaW5OZXdQYW5lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gSGFuZGxlIG1pZGRsZS1jbGljayAoYXV4Y2xpY2spIG9uIGludGVybmFsIGxpbmtzIHRvIG9wZW4gaW4gYSBuZXcgcGFuZVxuXHRcdGNvbXBvbmVudC5yZWdpc3RlckRvbUV2ZW50KGNvbnRhaW5lciwgJ2F1eGNsaWNrJywgKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG5cdFx0XHRpZiAoZXZlbnQuYnV0dG9uICE9PSAxKSByZXR1cm47IC8vIE9ubHkgaGFuZGxlIG1pZGRsZS1jbGlja3Ncblx0XHRcdGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudDtcblx0XHRcdGNvbnN0IGxpbmtFbGVtZW50ID0gdGFyZ2V0LmNsb3Nlc3QoJ2EuaW50ZXJuYWwtbGluaycpIGFzIEhUTUxBbmNob3JFbGVtZW50O1xuXHRcdFx0aWYgKGxpbmtFbGVtZW50KSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdGNvbnN0IGhyZWYgPSBsaW5rRWxlbWVudC5kYXRhc2V0LmhyZWY7XG5cdFx0XHRcdGlmIChocmVmKSB7XG5cdFx0XHRcdFx0dGhpcy5hcHAud29ya3NwYWNlLm9wZW5MaW5rVGV4dChocmVmLCBzb3VyY2VQYXRoLCB0cnVlKTsgLy8gQWx3YXlzIG9wZW4gaW4gbmV3IHBhbmUgZm9yIG1pZGRsZS1jbGlja1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogTG9hZHMgcGx1Z2luIHNldHRpbmdzIGZyb20gc3RvcmFnZSwgbWlncmF0aW5nIG9sZCBmb3JtYXRzIGlmIG5lY2Vzc2FyeS5cblx0ICovXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcblx0XHRjb25zdCBsb2FkZWREYXRhID0gYXdhaXQgdGhpcy5sb2FkRGF0YSgpO1xuXHRcdC8vIFN0YXJ0IHdpdGggYSBkZWVwIGNvcHkgb2YgZGVmYXVsdCBzZXR0aW5ncyB0byBlbnN1cmUgYWxsIGZpZWxkcyBhcmUgcHJlc2VudFxuXHRcdHRoaXMuc2V0dGluZ3MgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KERFRkFVTFRfU0VUVElOR1MpKTtcblxuXHRcdGlmIChsb2FkZWREYXRhKSB7XG5cdFx0XHQvLyBIYW5kbGUgcG90ZW50aWFsIG9sZCBnbG9iYWwgcmVuZGVyTG9jYXRpb24gc2V0dGluZyBmb3IgbWlncmF0aW9uXG5cdFx0XHRjb25zdCBvbGRHbG9iYWxSZW5kZXJMb2NhdGlvbiA9IGxvYWRlZERhdGEucmVuZGVyTG9jYXRpb24gYXMgUmVuZGVyTG9jYXRpb24gfCB1bmRlZmluZWQ7XG5cblx0XHRcdGlmIChsb2FkZWREYXRhLnJ1bGVzICYmIEFycmF5LmlzQXJyYXkobG9hZGVkRGF0YS5ydWxlcykpIHtcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5ydWxlcyA9IGxvYWRlZERhdGEucnVsZXMubWFwKChsb2FkZWRSdWxlOiBhbnkpID0+XG5cdFx0XHRcdFx0dGhpcy5fbWlncmF0ZVJ1bGUobG9hZGVkUnVsZSwgb2xkR2xvYmFsUmVuZGVyTG9jYXRpb24pXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBMb2FkIHRoZSBuZXcgcmVmcmVzaE9uRmlsZU9wZW4gc2V0dGluZyBpZiBpdCBleGlzdHMgaW4gbG9hZGVkRGF0YVxuXHRcdFx0aWYgKHR5cGVvZiBsb2FkZWREYXRhLnJlZnJlc2hPbkZpbGVPcGVuID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5yZWZyZXNoT25GaWxlT3BlbiA9IGxvYWRlZERhdGEucmVmcmVzaE9uRmlsZU9wZW47XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiBsb2FkZWREYXRhLnJlZnJlc2hPbkZpbGVPcGVuIGlzIHVuZGVmaW5lZCwgdGhpcy5zZXR0aW5ncy5yZWZyZXNoT25GaWxlT3BlblxuXHRcdFx0Ly8gd2lsbCByZXRhaW4gdGhlIHZhbHVlIGZyb20gREVGQVVMVF9TRVRUSU5HUyBkdWUgdG8gdGhlIGluaXRpYWwgZGVlcCBjb3B5LlxuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGVyZSdzIGF0IGxlYXN0IG9uZSBydWxlLCBhbmQgYWxsIHJ1bGVzIGFyZSBub3JtYWxpemVkXG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLnJ1bGVzIHx8IHRoaXMuc2V0dGluZ3MucnVsZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHQvLyBJZiBubyBydWxlcyBleGlzdCwgYWRkIGEgZGVmYXVsdCBvbmVcblx0XHRcdHRoaXMuc2V0dGluZ3MucnVsZXMgPSBbSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShERUZBVUxUX1NFVFRJTkdTLnJ1bGVzWzBdKSldO1xuXHRcdFx0dGhpcy5ub3JtYWxpemVSdWxlKHRoaXMuc2V0dGluZ3MucnVsZXNbMF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBOb3JtYWxpemUgYWxsIGV4aXN0aW5nIHJ1bGVzXG5cdFx0XHR0aGlzLnNldHRpbmdzLnJ1bGVzLmZvckVhY2gocnVsZSA9PiB0aGlzLm5vcm1hbGl6ZVJ1bGUocnVsZSkpO1xuXHRcdH1cblx0XHQvLyBFbnN1cmUgcmVmcmVzaE9uRmlsZU9wZW4gaXMgZGVmaW5pdGVseSBhIGJvb2xlYW4gKGl0IHNob3VsZCBiZSBieSBub3cpXG5cdFx0aWYgKHR5cGVvZiB0aGlzLnNldHRpbmdzLnJlZnJlc2hPbkZpbGVPcGVuICE9PSAnYm9vbGVhbicpIHtcblx0XHRcdHRoaXMuc2V0dGluZ3MucmVmcmVzaE9uRmlsZU9wZW4gPSBERUZBVUxUX1NFVFRJTkdTLnJlZnJlc2hPbkZpbGVPcGVuITtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTWlncmF0ZXMgYSBydWxlIGZyb20gYW4gb2xkZXIgc2V0dGluZ3MgZm9ybWF0IHRvIHRoZSBjdXJyZW50IFJ1bGUgaW50ZXJmYWNlLlxuXHQgKiBAcGFyYW0gbG9hZGVkUnVsZSBUaGUgcnVsZSBvYmplY3QgbG9hZGVkIGZyb20gc3RvcmFnZS5cblx0ICogQHBhcmFtIGdsb2JhbFJlbmRlckxvY2F0aW9uIEFuIG9wdGlvbmFsIGdsb2JhbCByZW5kZXIgbG9jYXRpb24gZnJvbSBhIHZlcnkgb2xkIHNldHRpbmdzIGZvcm1hdC5cblx0ICogQHJldHVybnMgQSBtaWdyYXRlZCBhbmQgbm9ybWFsaXplZCBSdWxlIG9iamVjdC5cblx0ICovXG5cdHByaXZhdGUgX21pZ3JhdGVSdWxlKGxvYWRlZFJ1bGU6IGFueSwgZ2xvYmFsUmVuZGVyTG9jYXRpb24/OiBSZW5kZXJMb2NhdGlvbik6IFJ1bGUge1xuXHRcdC8vIERldGVybWluZSBydWxlIHR5cGUsIGRlZmF1bHRpbmcgaWYgYW1iaWd1b3VzXG5cdFx0bGV0IHR5cGU6IFJ1bGVUeXBlO1xuXHRcdGlmIChPYmplY3QudmFsdWVzKFJ1bGVUeXBlKS5pbmNsdWRlcyhsb2FkZWRSdWxlLnR5cGUgYXMgUnVsZVR5cGUpKSB7XG5cdFx0XHR0eXBlID0gbG9hZGVkUnVsZS50eXBlIGFzIFJ1bGVUeXBlO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGxvYWRlZFJ1bGUuZm9sZGVyUGF0aCA9PT0gJ3N0cmluZycpIHsgLy8gTGVnYWN5IGZpZWxkXG5cdFx0XHR0eXBlID0gUnVsZVR5cGUuRm9sZGVyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0eXBlID0gREVGQVVMVF9TRVRUSU5HUy5ydWxlc1swXS50eXBlO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBjb250ZW50IHNvdXJjZSwgZGVmYXVsdGluZyBpZiBhbWJpZ3VvdXNcblx0XHRsZXQgY29udGVudFNvdXJjZTogQ29udGVudFNvdXJjZTtcblx0XHRpZiAoT2JqZWN0LnZhbHVlcyhDb250ZW50U291cmNlKS5pbmNsdWRlcyhsb2FkZWRSdWxlLmNvbnRlbnRTb3VyY2UgYXMgQ29udGVudFNvdXJjZSkpIHtcblx0XHRcdGNvbnRlbnRTb3VyY2UgPSBsb2FkZWRSdWxlLmNvbnRlbnRTb3VyY2UgYXMgQ29udGVudFNvdXJjZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSWYgZm9sZGVyUGF0aCBleGlzdGVkIChsZWdhY3kpIGFuZCBjb250ZW50U291cmNlIGlzIHVuZGVmaW5lZCwgaXQgd2FzIGxpa2VseSBUZXh0XG5cdFx0XHRjb250ZW50U291cmNlID0gKHR5cGVvZiBsb2FkZWRSdWxlLmZvbGRlclBhdGggPT09ICdzdHJpbmcnICYmIGxvYWRlZFJ1bGUuY29udGVudFNvdXJjZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHQ/IENvbnRlbnRTb3VyY2UuVGV4dFxuXHRcdFx0XHQ6IERFRkFVTFRfU0VUVElOR1MucnVsZXNbMF0uY29udGVudFNvdXJjZTtcblx0XHR9XG5cblx0XHRjb25zdCBtaWdyYXRlZFJ1bGU6IFJ1bGUgPSB7XG5cdFx0XHRuYW1lOiBsb2FkZWRSdWxlLm5hbWUgfHwgREVGQVVMVF9TRVRUSU5HUy5ydWxlc1swXS5uYW1lLFxuXHRcdFx0ZW5hYmxlZDogbG9hZGVkUnVsZS5lbmFibGVkICE9PSB1bmRlZmluZWQgPyBsb2FkZWRSdWxlLmVuYWJsZWQgOiBERUZBVUxUX1NFVFRJTkdTLnJ1bGVzWzBdLmVuYWJsZWQsXG5cdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0Y29udGVudFNvdXJjZTogY29udGVudFNvdXJjZSxcblx0XHRcdGZvb3RlclRleHQ6IGxvYWRlZFJ1bGUuZm9vdGVyVGV4dCB8fCAnJywgLy8gUmV0YWluIG5hbWUgZm9yIGNvbXBhdGliaWxpdHlcblx0XHRcdHJlbmRlckxvY2F0aW9uOiBsb2FkZWRSdWxlLnJlbmRlckxvY2F0aW9uIHx8IGdsb2JhbFJlbmRlckxvY2F0aW9uIHx8IERFRkFVTFRfU0VUVElOR1MucnVsZXNbMF0ucmVuZGVyTG9jYXRpb24sXG5cdFx0XHRyZWN1cnNpdmU6IGxvYWRlZFJ1bGUucmVjdXJzaXZlICE9PSB1bmRlZmluZWQgPyBsb2FkZWRSdWxlLnJlY3Vyc2l2ZSA6IHRydWUsXG5cdFx0fTtcblxuXHRcdC8vIFBvcHVsYXRlIHR5cGUtc3BlY2lmaWMgZmllbGRzXG5cdFx0aWYgKG1pZ3JhdGVkUnVsZS50eXBlID09PSBSdWxlVHlwZS5Gb2xkZXIpIHtcblx0XHRcdG1pZ3JhdGVkUnVsZS5wYXRoID0gbG9hZGVkUnVsZS5wYXRoICE9PSB1bmRlZmluZWQgPyBsb2FkZWRSdWxlLnBhdGggOlxuXHRcdFx0XHQobG9hZGVkUnVsZS5mb2xkZXJQYXRoICE9PSB1bmRlZmluZWQgPyBsb2FkZWRSdWxlLmZvbGRlclBhdGggOiBERUZBVUxUX1NFVFRJTkdTLnJ1bGVzWzBdLnBhdGgpO1xuXHRcdH0gZWxzZSBpZiAobWlncmF0ZWRSdWxlLnR5cGUgPT09IFJ1bGVUeXBlLlRhZykge1xuXHRcdFx0bWlncmF0ZWRSdWxlLnRhZyA9IGxvYWRlZFJ1bGUudGFnICE9PSB1bmRlZmluZWQgPyBsb2FkZWRSdWxlLnRhZyA6ICcnO1xuXHRcdFx0bWlncmF0ZWRSdWxlLmluY2x1ZGVTdWJ0YWdzID0gbG9hZGVkUnVsZS5pbmNsdWRlU3VidGFncyAhPT0gdW5kZWZpbmVkID8gbG9hZGVkUnVsZS5pbmNsdWRlU3VidGFncyA6IGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAobWlncmF0ZWRSdWxlLnR5cGUgPT09IFJ1bGVUeXBlLlByb3BlcnR5KSB7XG5cdFx0XHRtaWdyYXRlZFJ1bGUucHJvcGVydHlOYW1lID0gbG9hZGVkUnVsZS5wcm9wZXJ0eU5hbWUgfHwgJyc7XG5cdFx0XHRtaWdyYXRlZFJ1bGUucHJvcGVydHlWYWx1ZSA9IGxvYWRlZFJ1bGUucHJvcGVydHlWYWx1ZSB8fCAnJztcblx0XHR9XG5cblx0XHQvLyBQb3B1bGF0ZSBjb250ZW50IHNvdXJjZS1zcGVjaWZpYyBmaWVsZHNcblx0XHRpZiAobWlncmF0ZWRSdWxlLmNvbnRlbnRTb3VyY2UgPT09IENvbnRlbnRTb3VyY2UuRmlsZSkge1xuXHRcdFx0bWlncmF0ZWRSdWxlLmZvb3RlckZpbGVQYXRoID0gbG9hZGVkUnVsZS5mb290ZXJGaWxlUGF0aCB8fCAnJzsgLy8gUmV0YWluIG5hbWUgZm9yIGNvbXBhdGliaWxpdHlcblx0XHR9XG5cdFx0cmV0dXJuIG1pZ3JhdGVkUnVsZTsgLy8gTm9ybWFsaXphdGlvbiB3aWxsIGhhcHBlbiBhZnRlciBtaWdyYXRpb25cblx0fVxuXG5cdC8qKlxuXHQgKiBOb3JtYWxpemVzIGEgcnVsZSBvYmplY3QsIGVuc3VyaW5nIGFsbCByZXF1aXJlZCBmaWVsZHMgYXJlIHByZXNlbnQgYW5kIGRlZmF1bHRzIGFyZSBhcHBsaWVkLlxuXHQgKiBBbHNvIGNsZWFucyB1cCBmaWVsZHMgdGhhdCBhcmUgbm90IHJlbGV2YW50IHRvIHRoZSBydWxlJ3MgY3VycmVudCB0eXBlIG9yIGNvbnRlbnQgc291cmNlLlxuXHQgKiBAcGFyYW0gcnVsZSBUaGUgcnVsZSB0byBub3JtYWxpemUuXG5cdCAqL1xuXHRwdWJsaWMgbm9ybWFsaXplUnVsZShydWxlOiBSdWxlKTogdm9pZCB7XG5cdFx0Ly8gRW5zdXJlIGJhc2ljIGZpZWxkcyBoYXZlIGRlZmF1bHQgdmFsdWVzXG5cdFx0cnVsZS5uYW1lID0gcnVsZS5uYW1lID09PSB1bmRlZmluZWQgPyBERUZBVUxUX1NFVFRJTkdTLnJ1bGVzWzBdLm5hbWUgOiBydWxlLm5hbWU7XG5cdFx0cnVsZS5lbmFibGVkID0gdHlwZW9mIHJ1bGUuZW5hYmxlZCA9PT0gJ2Jvb2xlYW4nID8gcnVsZS5lbmFibGVkIDogREVGQVVMVF9TRVRUSU5HUy5ydWxlc1swXS5lbmFibGVkITtcblx0XHRydWxlLnR5cGUgPSBydWxlLnR5cGUgfHwgREVGQVVMVF9TRVRUSU5HUy5ydWxlc1swXS50eXBlO1xuXG5cdFx0Ly8gTm9ybWFsaXplIGJhc2VkIG9uIFJ1bGVUeXBlXG5cdFx0aWYgKHJ1bGUudHlwZSA9PT0gUnVsZVR5cGUuRm9sZGVyKSB7XG5cdFx0XHRydWxlLnBhdGggPSBydWxlLnBhdGggPT09IHVuZGVmaW5lZCA/IChERUZBVUxUX1NFVFRJTkdTLnJ1bGVzWzBdLnBhdGggfHwgJycpIDogcnVsZS5wYXRoO1xuXHRcdFx0Ly8gJ3JlY3Vyc2l2ZScgaXMgYWx3YXlzIHRydWUgaWYgcGF0aCBpcyBcIlwiIChhbGwgZmlsZXMpXG5cdFx0XHRydWxlLnJlY3Vyc2l2ZSA9IHJ1bGUucGF0aCA9PT0gXCJcIiA/IHRydWUgOiAodHlwZW9mIHJ1bGUucmVjdXJzaXZlID09PSAnYm9vbGVhbicgPyBydWxlLnJlY3Vyc2l2ZSA6IHRydWUpO1xuXHRcdFx0Ly8gRGVsZXRlIGZpZWxkcyBub3QgYXBwbGljYWJsZSB0byBGb2xkZXIgdHlwZVxuXHRcdFx0ZGVsZXRlIHJ1bGUudGFnO1xuXHRcdFx0ZGVsZXRlIHJ1bGUuaW5jbHVkZVN1YnRhZ3M7XG5cdFx0XHRkZWxldGUgcnVsZS5wcm9wZXJ0eU5hbWU7XG5cdFx0XHRkZWxldGUgcnVsZS5wcm9wZXJ0eVZhbHVlO1xuXHRcdH0gZWxzZSBpZiAocnVsZS50eXBlID09PSBSdWxlVHlwZS5UYWcpIHtcblx0XHRcdHJ1bGUudGFnID0gcnVsZS50YWcgPT09IHVuZGVmaW5lZCA/ICcnIDogcnVsZS50YWc7XG5cdFx0XHRydWxlLmluY2x1ZGVTdWJ0YWdzID0gdHlwZW9mIHJ1bGUuaW5jbHVkZVN1YnRhZ3MgPT09ICdib29sZWFuJyA/IHJ1bGUuaW5jbHVkZVN1YnRhZ3MgOiBmYWxzZTtcblx0XHRcdGRlbGV0ZSBydWxlLnBhdGg7XG5cdFx0XHRkZWxldGUgcnVsZS5yZWN1cnNpdmU7XG5cdFx0XHRkZWxldGUgcnVsZS5wcm9wZXJ0eU5hbWU7XG5cdFx0XHRkZWxldGUgcnVsZS5wcm9wZXJ0eVZhbHVlO1xuXHRcdH0gZWxzZSBpZiAocnVsZS50eXBlID09PSBSdWxlVHlwZS5Qcm9wZXJ0eSkge1xuXHRcdFx0cnVsZS5wcm9wZXJ0eU5hbWUgPSBydWxlLnByb3BlcnR5TmFtZSA9PT0gdW5kZWZpbmVkID8gJycgOiBydWxlLnByb3BlcnR5TmFtZTtcblx0XHRcdHJ1bGUucHJvcGVydHlWYWx1ZSA9IHJ1bGUucHJvcGVydHlWYWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiBydWxlLnByb3BlcnR5VmFsdWU7XG5cdFx0XHRkZWxldGUgcnVsZS5wYXRoO1xuXHRcdFx0ZGVsZXRlIHJ1bGUucmVjdXJzaXZlO1xuXHRcdFx0ZGVsZXRlIHJ1bGUudGFnO1xuXHRcdFx0ZGVsZXRlIHJ1bGUuaW5jbHVkZVN1YnRhZ3M7XG5cdFx0fVxuXG5cdFx0Ly8gTm9ybWFsaXplIGNvbnRlbnQgc291cmNlIGFuZCByZWxhdGVkIGZpZWxkc1xuXHRcdHJ1bGUuY29udGVudFNvdXJjZSA9IHJ1bGUuY29udGVudFNvdXJjZSB8fCBERUZBVUxUX1NFVFRJTkdTLnJ1bGVzWzBdLmNvbnRlbnRTb3VyY2U7XG5cdFx0cnVsZS5mb290ZXJUZXh0ID0gcnVsZS5mb290ZXJUZXh0IHx8ICcnOyAvLyBSZXRhaW4gbmFtZSBmb3IgY29tcGF0aWJpbGl0eVxuXHRcdHJ1bGUucmVuZGVyTG9jYXRpb24gPSBydWxlLnJlbmRlckxvY2F0aW9uIHx8IERFRkFVTFRfU0VUVElOR1MucnVsZXNbMF0ucmVuZGVyTG9jYXRpb247XG5cblx0XHRpZiAocnVsZS5jb250ZW50U291cmNlID09PSBDb250ZW50U291cmNlLkZpbGUpIHtcblx0XHRcdHJ1bGUuZm9vdGVyRmlsZVBhdGggPSBydWxlLmZvb3RlckZpbGVQYXRoIHx8ICcnOyAvLyBSZXRhaW4gbmFtZSBmb3IgY29tcGF0aWJpbGl0eVxuXHRcdH0gZWxzZSB7IC8vIENvbnRlbnRTb3VyY2UuVGV4dFxuXHRcdFx0ZGVsZXRlIHJ1bGUuZm9vdGVyRmlsZVBhdGg7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNhdmVzIHRoZSBjdXJyZW50IHBsdWdpbiBzZXR0aW5ncyB0byBzdG9yYWdlIGFuZCB0cmlnZ2VycyBhIHZpZXcgcmVmcmVzaC5cblx0ICovXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcblx0XHQvLyBFbnN1cmUgYWxsIHJ1bGVzIGFyZSBub3JtYWxpemVkIGJlZm9yZSBzYXZpbmdcblx0XHR0aGlzLnNldHRpbmdzLnJ1bGVzLmZvckVhY2gocnVsZSA9PiB0aGlzLm5vcm1hbGl6ZVJ1bGUocnVsZSkpO1xuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG5cdFx0dGhpcy5oYW5kbGVBY3RpdmVWaWV3Q2hhbmdlKCk7IC8vIFJlZnJlc2ggdmlld3MgdG8gYXBwbHkgY2hhbmdlc1xuXHR9XG59XG5cbi8vIC0tLSBTZXR0aW5ncyBUYWIgQ2xhc3MgLS0tXG5cbi8qKlxuICogTWFuYWdlcyB0aGUgc2V0dGluZ3MgdGFiIFVJIGZvciB0aGUgVmlydHVhbEZvb3RlciBwbHVnaW4uXG4gKiBBbGxvd3MgdXNlcnMgdG8gY29uZmlndXJlIHJ1bGVzIGZvciBkeW5hbWljIGNvbnRlbnQgaW5qZWN0aW9uLlxuICovXG5jbGFzcyBWaXJ0dWFsRm9vdGVyU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuXHQvLyBDYWNoZXMgZm9yIHN1Z2dlc3Rpb24gbGlzdHMgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZVxuXHRwcml2YXRlIGFsbEZvbGRlclBhdGhzQ2FjaGU6IFNldDxzdHJpbmc+IHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgYWxsVGFnc0NhY2hlOiBTZXQ8c3RyaW5nPiB8IG51bGwgPSBudWxsO1xuXHRwcml2YXRlIGFsbE1hcmtkb3duRmlsZVBhdGhzQ2FjaGU6IFNldDxzdHJpbmc+IHwgbnVsbCA9IG51bGw7XG5cdHByaXZhdGUgYWxsUHJvcGVydHlOYW1lc0NhY2hlOiBTZXQ8c3RyaW5nPiB8IG51bGwgPSBudWxsO1xuXHRwcml2YXRlIHJ1bGVFeHBhbmRlZFN0YXRlczogYm9vbGVhbltdID0gW107XG5cblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcHJpdmF0ZSBwbHVnaW46IFZpcnR1YWxGb290ZXJQbHVnaW4pIHtcblx0XHRzdXBlcihhcHAsIHBsdWdpbik7XG5cdH1cblxuXHQvKipcblx0ICogTGF6aWx5IGdldHMgYW5kIGNhY2hlcyBhbGwgdW5pcXVlIGZvbGRlciBwYXRocyBpbiB0aGUgdmF1bHQuXG5cdCAqIEluY2x1ZGVzIHNwZWNpYWwgcGF0aHMgXCJcIiAoYWxsIGZpbGVzKSBhbmQgXCIvXCIgKHJvb3QpLlxuXHQgKiBAcmV0dXJucyBBIHNldCBvZiBhdmFpbGFibGUgZm9sZGVyIHBhdGhzLlxuXHQgKi9cblx0cHJpdmF0ZSBnZXRBdmFpbGFibGVGb2xkZXJQYXRocygpOiBTZXQ8c3RyaW5nPiB7XG5cdFx0aWYgKHRoaXMuYWxsRm9sZGVyUGF0aHNDYWNoZSkgcmV0dXJuIHRoaXMuYWxsRm9sZGVyUGF0aHNDYWNoZTtcblxuXHRcdGNvbnN0IHBhdGhzID0gbmV3IFNldDxzdHJpbmc+KFsnLycsICcnXSk7IC8vIFNwZWNpYWwgcGF0aHNcblx0XHR0aGlzLmFwcC52YXVsdC5nZXRBbGxMb2FkZWRGaWxlcygpLmZvckVhY2goZmlsZSA9PiB7XG5cdFx0XHRpZiAoZmlsZS5wYXJlbnQpIHsgLy8gSGFzIGEgcGFyZW50IGZvbGRlclxuXHRcdFx0XHRjb25zdCBwYXJlbnRQYXRoID0gZmlsZS5wYXJlbnQuaXNSb290KCkgPyAnLycgOiAoZmlsZS5wYXJlbnQucGF0aC5lbmRzV2l0aCgnLycpID8gZmlsZS5wYXJlbnQucGF0aCA6IGZpbGUucGFyZW50LnBhdGggKyAnLycpO1xuXHRcdFx0XHRpZiAocGFyZW50UGF0aCAhPT0gJy8nKSBwYXRocy5hZGQocGFyZW50UGF0aCk7IC8vIEFkZCBwYXJlbnQgcGF0aCwgZW5zdXJpbmcgdHJhaWxpbmcgc2xhc2hcblx0XHRcdH1cblx0XHRcdC8vIElmIHRoZSBmaWxlIGl0c2VsZiBpcyBhIGZvbGRlciAoT2JzaWRpYW4ncyBURm9sZGVyKVxuXHRcdFx0aWYgKCdjaGlsZHJlbicgaW4gZmlsZSAmJiBmaWxlLnBhdGggIT09ICcvJykgeyAvLyAnY2hpbGRyZW4nIGluZGljYXRlcyBhIFRGb2xkZXJcblx0XHRcdFx0Y29uc3QgZm9sZGVyUGF0aCA9IGZpbGUucGF0aC5lbmRzV2l0aCgnLycpID8gZmlsZS5wYXRoIDogZmlsZS5wYXRoICsgJy8nO1xuXHRcdFx0XHRwYXRocy5hZGQoZm9sZGVyUGF0aCk7IC8vIEFkZCBmb2xkZXIgcGF0aCwgZW5zdXJpbmcgdHJhaWxpbmcgc2xhc2hcblx0XHRcdH1cblx0XHR9KTtcblx0XHR0aGlzLmFsbEZvbGRlclBhdGhzQ2FjaGUgPSBwYXRocztcblx0XHRyZXR1cm4gcGF0aHM7XG5cdH1cblxuXHQvKipcblx0ICogTGF6aWx5IGdldHMgYW5kIGNhY2hlcyBhbGwgdW5pcXVlIHRhZ3MgKHdpdGhvdXQgJyMnKSBwcmVzZW50IGluIE1hcmtkb3duIGZpbGVzLlxuXHQgKiBAcmV0dXJucyBBIHNldCBvZiBhdmFpbGFibGUgdGFncy5cblx0ICovXG5cdHByaXZhdGUgZ2V0QXZhaWxhYmxlVGFncygpOiBTZXQ8c3RyaW5nPiB7XG5cdFx0aWYgKHRoaXMuYWxsVGFnc0NhY2hlKSByZXR1cm4gdGhpcy5hbGxUYWdzQ2FjaGU7XG5cblx0XHRjb25zdCBjb2xsZWN0ZWRUYWdzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cdFx0dGhpcy5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpLmZvckVhY2goZmlsZSA9PiB7XG5cdFx0XHRjb25zdCBmaWxlQ2FjaGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcblx0XHRcdGlmIChmaWxlQ2FjaGUpIHtcblx0XHRcdFx0Y29uc3QgdGFnc0luRmlsZSA9IGdldEFsbFRhZ3MoZmlsZUNhY2hlKTsgLy8gUmV0dXJucyB0YWdzIHdpdGggJyMnXG5cdFx0XHRcdHRhZ3NJbkZpbGU/LmZvckVhY2godGFnID0+IHtcblx0XHRcdFx0XHRjb2xsZWN0ZWRUYWdzLmFkZCh0YWcuc3Vic3RyaW5nKDEpKTsgLy8gU3RvcmUgd2l0aG91dCAnIydcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0dGhpcy5hbGxUYWdzQ2FjaGUgPSBjb2xsZWN0ZWRUYWdzO1xuXHRcdHJldHVybiBjb2xsZWN0ZWRUYWdzO1xuXHR9XG5cblx0LyoqXG5cdCAqIExhemlseSBnZXRzIGFuZCBjYWNoZXMgYWxsIE1hcmtkb3duIGZpbGUgcGF0aHMgaW4gdGhlIHZhdWx0LlxuXHQgKiBAcmV0dXJucyBBIHNldCBvZiBhdmFpbGFibGUgTWFya2Rvd24gZmlsZSBwYXRocy5cblx0ICovXG5cdHByaXZhdGUgZ2V0QXZhaWxhYmxlTWFya2Rvd25GaWxlUGF0aHMoKTogU2V0PHN0cmluZz4ge1xuXHRcdGlmICh0aGlzLmFsbE1hcmtkb3duRmlsZVBhdGhzQ2FjaGUpIHJldHVybiB0aGlzLmFsbE1hcmtkb3duRmlsZVBhdGhzQ2FjaGU7XG5cblx0XHRjb25zdCBwYXRocyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXHRcdHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKS5mb3JFYWNoKGZpbGUgPT4ge1xuXHRcdFx0cGF0aHMuYWRkKGZpbGUucGF0aCk7XG5cdFx0fSk7XG5cdFx0dGhpcy5hbGxNYXJrZG93bkZpbGVQYXRoc0NhY2hlID0gcGF0aHM7XG5cdFx0cmV0dXJuIHBhdGhzO1xuXHR9XG5cblx0LyoqXG5cdCAqIExhemlseSBnZXRzIGFuZCBjYWNoZXMgYWxsIHVuaXF1ZSBmcm9udG1hdHRlciBwcm9wZXJ0eSBrZXlzIGZyb20gTWFya2Rvd24gZmlsZXMuXG5cdCAqIEByZXR1cm5zIEEgc2V0IG9mIGF2YWlsYWJsZSBwcm9wZXJ0eSBuYW1lcy5cblx0ICovXG5cdHByaXZhdGUgZ2V0QXZhaWxhYmxlUHJvcGVydHlOYW1lcygpOiBTZXQ8c3RyaW5nPiB7XG5cdFx0aWYgKHRoaXMuYWxsUHJvcGVydHlOYW1lc0NhY2hlKSByZXR1cm4gdGhpcy5hbGxQcm9wZXJ0eU5hbWVzQ2FjaGU7XG5cblx0XHQvLyBAdHMtaWdub3JlIC0gZ2V0RnJvbnRtYXR0ZXJQcm9wZXJ0eUtleXMgaXMgYW4gdW5kb2N1bWVudGVkIEFQSSwgYnV0IHdpZGVseSB1c2VkLlxuXHRcdGNvbnN0IGtleXMgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZyb250bWF0dGVyUHJvcGVydHlLZXlzPy4oKSB8fCBbXTtcblx0XHR0aGlzLmFsbFByb3BlcnR5TmFtZXNDYWNoZSA9IG5ldyBTZXQoa2V5cyk7XG5cdFx0cmV0dXJuIHRoaXMuYWxsUHJvcGVydHlOYW1lc0NhY2hlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbmRlcnMgdGhlIHNldHRpbmdzIHRhYiBVSS5cblx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IE9ic2lkaWFuIHdoZW4gdGhlIHNldHRpbmdzIHRhYiBpcyBvcGVuZWQuXG5cdCAqL1xuXHRkaXNwbGF5KCk6IHZvaWQge1xuXHRcdGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTsgLy8gQ2xlYXIgcHJldmlvdXMgY29udGVudFxuXG5cdFx0Ly8gLS0tIFBsdWdpbiBIZWFkZXIgLS0tXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnVmlydHVhbCBDb250ZW50IFNldHRpbmdzJyB9KTtcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHsgdGV4dDogJ0RlZmluZSBydWxlcyB0byBkeW5hbWljYWxseSBhZGQgY29udGVudCB0byB0aGUgaGVhZGVyIG9yIGZvb3RlciBvZiBub3RlcyBiYXNlZCBvbiB0aGVpciBmb2xkZXIsIHRhZ3MsIG9yIHByb3BlcnRpZXMuJyB9KTtcblxuXHRcdC8vIC0tLSBHZW5lcmFsIFNldHRpbmdzIFNlY3Rpb24gLS0tXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnUmVmcmVzaCBvbiBmb2N1cyBjaGFuZ2UnKVxuXHRcdFx0LnNldERlc2MoJ0lmIGVuYWJsZWQsIHZpcnR1YWwgY29udGVudCB3aWxsIHJlZnJlc2ggd2hlbiBzd2l0Y2hpbmcgZmlsZXMuIFRoaXMgbWF5IGNhdXNlIGEgc2xpZ2h0IGZsaWNrZXIgYnV0IGlzIHVzZWZ1bCBpZiB5b3UgZnJlcXVlbnRseSBjaGFuZ2UgdGhlIHRleHQgb2YgdmlydHVhbCBjb250ZW50IGFuZCBuZWVkIGltbWVkaWF0ZSB1cGRhdGVzLiBJZiBkaXNhYmxlZCB0aGUgdmlydHVhbCBjb250ZW50IHdpbGwgYmUgdXBkYXRlZCBvbiBmaWxlIG9wZW4gYW5kIHZpZXcgY2hhbmdlIChlZGl0aW5nL3JlYWRpbmcgdmlldykuIERpc2FibGVkIGJ5IGRlZmF1bHQuJylcblx0XHRcdC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucmVmcmVzaE9uRmlsZU9wZW4hKSAvLyBWYWx1ZSBpcyBlbnN1cmVkIGJ5IGxvYWRTZXR0aW5nc1xuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MucmVmcmVzaE9uRmlsZU9wZW4gPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSkpO1xuXHRcdFxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ1J1bGVzJyB9KTtcblxuXG5cdFx0Ly8gSW52YWxpZGF0ZSBjYWNoZXMgdG8gZW5zdXJlIGZyZXNoIHN1Z2dlc3Rpb25zIGVhY2ggdGltZSB0aGUgdGFiIGlzIGRpc3BsYXllZFxuXHRcdHRoaXMuYWxsRm9sZGVyUGF0aHNDYWNoZSA9IG51bGw7XG5cdFx0dGhpcy5hbGxUYWdzQ2FjaGUgPSBudWxsO1xuXHRcdHRoaXMuYWxsTWFya2Rvd25GaWxlUGF0aHNDYWNoZSA9IG51bGw7XG5cdFx0dGhpcy5hbGxQcm9wZXJ0eU5hbWVzQ2FjaGUgPSBudWxsO1xuXG5cdFx0Ly8gU3luY2hyb25pemUgcnVsZUV4cGFuZGVkU3RhdGVzIHdpdGggdGhlIGN1cnJlbnQgbnVtYmVyIG9mIHJ1bGVzXG5cdFx0Y29uc3QgbnVtUnVsZXMgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5ydWxlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKHRoaXMucnVsZUV4cGFuZGVkU3RhdGVzLmxlbmd0aCA8IG51bVJ1bGVzKSB7XG5cdFx0XHR0aGlzLnJ1bGVFeHBhbmRlZFN0YXRlcy5wdXNoKGZhbHNlKTsgLy8gRGVmYXVsdCBuZXcgcnVsZXMgdG8gY29sbGFwc2VkXG5cdFx0fVxuXHRcdGlmICh0aGlzLnJ1bGVFeHBhbmRlZFN0YXRlcy5sZW5ndGggPiBudW1SdWxlcykge1xuXHRcdFx0dGhpcy5ydWxlRXhwYW5kZWRTdGF0ZXMubGVuZ3RoID0gbnVtUnVsZXM7IC8vIFRydW5jYXRlIGlmIHJ1bGVzIHdlcmUgcmVtb3ZlZFxuXHRcdH1cblxuXG5cdFx0Y29uc3QgcnVsZXNDb250YWluZXIgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoJ3J1bGVzLWNvbnRhaW5lciB2aXJ0dWFsLWZvb3Rlci1ydWxlcy1jb250YWluZXInKTtcblxuXHRcdC8vIEVuc3VyZSBzZXR0aW5ncy5ydWxlcyBhcnJheSBleGlzdHMgYW5kIGhhcyBhdCBsZWFzdCBvbmUgcnVsZVxuXHRcdGlmICghdGhpcy5wbHVnaW4uc2V0dGluZ3MucnVsZXMpIHtcblx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bGVzID0gW107XG5cdFx0fVxuXHRcdGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5ydWxlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdGNvbnN0IG5ld1J1bGUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KERFRkFVTFRfU0VUVElOR1MucnVsZXNbMF0pKTtcblx0XHRcdHRoaXMucGx1Z2luLm5vcm1hbGl6ZVJ1bGUobmV3UnVsZSk7IC8vIE5vcm1hbGl6ZSB0aGUgbmV3IGRlZmF1bHQgcnVsZVxuXHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MucnVsZXMucHVzaChuZXdSdWxlKTtcblx0XHRcdC8vIEVuc3VyZSBydWxlRXhwYW5kZWRTdGF0ZXMgaXMgdXBkYXRlZCBmb3IgdGhlIG5ldyBydWxlXG5cdFx0XHRpZiAodGhpcy5ydWxlRXhwYW5kZWRTdGF0ZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHRoaXMucnVsZUV4cGFuZGVkU3RhdGVzLnB1c2goZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbmRlciBjb250cm9scyBmb3IgZWFjaCBydWxlXG5cdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MucnVsZXMuZm9yRWFjaCgocnVsZSwgaW5kZXgpID0+IHtcblx0XHRcdHRoaXMucmVuZGVyUnVsZUNvbnRyb2xzKHJ1bGUsIGluZGV4LCBydWxlc0NvbnRhaW5lcik7XG5cdFx0fSk7XG5cblx0XHQvLyAtLS0gQWRkIE5ldyBSdWxlIEJ1dHRvbiAtLS1cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuXHRcdFx0XHQuc2V0QnV0dG9uVGV4dCgnQWRkIG5ldyBydWxlJylcblx0XHRcdFx0LnNldEN0YSgpIC8vIENhbGwgdG8gYWN0aW9uIHN0eWxlXG5cdFx0XHRcdC5zZXRDbGFzcygndmlydHVhbC1mb290ZXItYWRkLWJ1dHRvbicpXG5cdFx0XHRcdC5vbkNsaWNrKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRjb25zdCBuZXdSdWxlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShERUZBVUxUX1NFVFRJTkdTLnJ1bGVzWzBdKSk7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4ubm9ybWFsaXplUnVsZShuZXdSdWxlKTtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5ydWxlcy5wdXNoKG5ld1J1bGUpO1xuXHRcdFx0XHRcdHRoaXMucnVsZUV4cGFuZGVkU3RhdGVzLnB1c2godHJ1ZSk7IC8vIE5ldyBydWxlIGlzIGluaXRpYWxseSBleHBhbmRlZFxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdHRoaXMuZGlzcGxheSgpOyAvLyBSZS1yZW5kZXIgdG8gc2hvdyB0aGUgbmV3IHJ1bGUgYW5kIHVwZGF0ZSBpbmRpY2VzXG5cdFx0XHRcdH0pKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW5kZXJzIHRoZSBVSSBjb250cm9scyBmb3IgYSBzaW5nbGUgcnVsZSB3aXRoaW4gdGhlIHNldHRpbmdzIHRhYi5cblx0ICogQHBhcmFtIHJ1bGUgVGhlIHJ1bGUgb2JqZWN0IHRvIHJlbmRlciBjb250cm9scyBmb3IuXG5cdCAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHJ1bGUgaW4gdGhlIHNldHRpbmdzIGFycmF5LlxuXHQgKiBAcGFyYW0gY29udGFpbmVyRWwgVGhlIHBhcmVudCBIVE1MRWxlbWVudCB0byBhcHBlbmQgdGhlIHJ1bGUgY29udHJvbHMgdG8uXG5cdCAqL1xuXHRwcml2YXRlIHJlbmRlclJ1bGVDb250cm9scyhydWxlOiBSdWxlLCBpbmRleDogbnVtYmVyLCBjb250YWluZXJFbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcblx0XHRjb25zdCBydWxlRGl2ID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KCdydWxlLWl0ZW0gdmlydHVhbC1mb290ZXItcnVsZS1pdGVtJyk7XG5cdFx0XG5cdFx0Ly8gQXBwbHkgc3RvcmVkIGV4cGFuc2lvbiBzdGF0ZSBvciBkZWZhdWx0IHRvIGNvbGxhcHNlZFxuXHRcdGlmICghdGhpcy5ydWxlRXhwYW5kZWRTdGF0ZXNbaW5kZXhdKSB7XG5cdFx0XHRydWxlRGl2LmFkZENsYXNzKCdpcy1jb2xsYXBzZWQnKTtcblx0XHR9XG5cblx0XHRjb25zdCBydWxlTmFtZURpc3BsYXkgPSAocnVsZS5uYW1lICYmIHJ1bGUubmFtZS50cmltKCkgIT09ICcnKSA/IHJ1bGUubmFtZSA6ICdVbm5hbWVkIFJ1bGUnO1xuXHRcdGNvbnN0IHJ1bGVIZWFkaW5nVGV4dCA9IGBSdWxlICR7aW5kZXggKyAxfTogJHtydWxlTmFtZURpc3BsYXl9YDtcblx0XHRjb25zdCBydWxlSGVhZGluZyA9IHJ1bGVEaXYuY3JlYXRlRWwoJ2g0JywgeyB0ZXh0OiBydWxlSGVhZGluZ1RleHQgfSk7XG5cdFx0cnVsZUhlYWRpbmcuYWRkQ2xhc3MoJ3ZpcnR1YWwtZm9vdGVyLXJ1bGUtaGVhZGluZycpO1xuXG5cblx0XHRjb25zdCBydWxlQ29udGVudENvbnRhaW5lciA9IHJ1bGVEaXYuY3JlYXRlRGl2KCd2aXJ0dWFsLWZvb3Rlci1ydWxlLWNvbnRlbnQnKTtcblxuXHRcdC8vIFRvZ2dsZSBjb2xsYXBzZS9leHBhbmQgb24gaGVhZGluZyBjbGljayBhbmQgdXBkYXRlIHN0YXRlXG5cdFx0cnVsZUhlYWRpbmcuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG5cdFx0XHRjb25zdCBpc05vd0V4cGFuZGVkID0gIXJ1bGVEaXYuY2xhc3NMaXN0LnRvZ2dsZSgnaXMtY29sbGFwc2VkJyk7XG5cdFx0XHR0aGlzLnJ1bGVFeHBhbmRlZFN0YXRlc1tpbmRleF0gPSBpc05vd0V4cGFuZGVkO1xuXHRcdH0pO1xuXG5cdFx0Ly8gLS0tIFJ1bGUgTmFtZSBTZXR0aW5nIC0tLVxuXHRcdG5ldyBTZXR0aW5nKHJ1bGVDb250ZW50Q29udGFpbmVyKVxuXHRcdFx0LnNldE5hbWUoJ1J1bGUgbmFtZScpXG5cdFx0XHQuc2V0RGVzYygnQSBkZXNjcmlwdGl2ZSBuYW1lIGZvciB0aGlzIHJ1bGUgKGUuZy4sIFwiUHJvamVjdCBOb3RlcyBGb290ZXJcIikuJylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoJ2UuZy4sIEJsb2cgUG9zdCBGb290ZXInKVxuXHRcdFx0XHQuc2V0VmFsdWUocnVsZS5uYW1lIHx8ICcnKVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0cnVsZS5uYW1lID0gdmFsdWU7XG5cdFx0XHRcdFx0Ly8gVXBkYXRlIGhlYWRpbmcgdGV4dCBkeW5hbWljYWxseVxuXHRcdFx0XHRcdGNvbnN0IG5ld05hbWVEaXNwbGF5ID0gKHZhbHVlICYmIHZhbHVlLnRyaW0oKSAhPT0gJycpID8gdmFsdWUgOiAnVW5uYW1lZCBSdWxlJztcblx0XHRcdFx0XHRydWxlSGVhZGluZy50ZXh0Q29udGVudCA9IGBSdWxlICR7aW5kZXggKyAxfTogJHtuZXdOYW1lRGlzcGxheX1gO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHR9KSk7XG5cblx0XHQvLyAtLS0gRW5hYmxlZC9EaXNhYmxlZCBUb2dnbGUgLS0tXG5cdFx0bmV3IFNldHRpbmcocnVsZUNvbnRlbnRDb250YWluZXIpXG5cdFx0XHQuc2V0TmFtZSgnRW5hYmxlZCcpXG5cdFx0XHQuc2V0RGVzYygnSWYgZGlzYWJsZWQsIHRoaXMgcnVsZSB3aWxsIG5vdCBiZSBhcHBsaWVkLicpXG5cdFx0XHQuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcblx0XHRcdFx0LnNldFZhbHVlKHJ1bGUuZW5hYmxlZCEpIC8vIG5vcm1hbGl6ZVJ1bGUgZW5zdXJlcyAnZW5hYmxlZCcgaXMgYm9vbGVhblxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0cnVsZS5lbmFibGVkID0gdmFsdWU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdH0pKTtcblxuXHRcdC8vIC0tLSBSdWxlIFR5cGUgU2V0dGluZyAtLS1cblx0XHRuZXcgU2V0dGluZyhydWxlQ29udGVudENvbnRhaW5lcilcblx0XHRcdC5zZXROYW1lKCdSdWxlIHR5cGUnKVxuXHRcdFx0LnNldERlc2MoJ0FwcGx5IHRoaXMgcnVsZSBiYXNlZCBvbiBmb2xkZXIsIHRhZywgb3IgcHJvcGVydHkuJylcblx0XHRcdC5hZGREcm9wZG93bihkcm9wZG93biA9PiBkcm9wZG93blxuXHRcdFx0XHQuYWRkT3B0aW9uKFJ1bGVUeXBlLkZvbGRlciwgJ0ZvbGRlcicpXG5cdFx0XHRcdC5hZGRPcHRpb24oUnVsZVR5cGUuVGFnLCAnVGFnJylcblx0XHRcdFx0LmFkZE9wdGlvbihSdWxlVHlwZS5Qcm9wZXJ0eSwgJ1Byb3BlcnR5Jylcblx0XHRcdFx0LnNldFZhbHVlKHJ1bGUudHlwZSlcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogc3RyaW5nKSA9PiB7XG5cdFx0XHRcdFx0cnVsZS50eXBlID0gdmFsdWUgYXMgUnVsZVR5cGU7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4ubm9ybWFsaXplUnVsZShydWxlKTsgLy8gUmUtbm9ybWFsaXplIGZvciB0eXBlLXNwZWNpZmljIGZpZWxkc1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdHRoaXMuZGlzcGxheSgpOyAvLyBSZS1yZW5kZXIgdG8gc2hvdy9oaWRlIHR5cGUtc3BlY2lmaWMgc2V0dGluZ3Ncblx0XHRcdFx0fSkpO1xuXG5cdFx0Ly8gLS0tIFR5cGUtU3BlY2lmaWMgU2V0dGluZ3MgLS0tXG5cdFx0aWYgKHJ1bGUudHlwZSA9PT0gUnVsZVR5cGUuRm9sZGVyKSB7XG5cdFx0XHRuZXcgU2V0dGluZyhydWxlQ29udGVudENvbnRhaW5lcilcblx0XHRcdFx0LnNldE5hbWUoJ0ZvbGRlciBwYXRoJylcblx0XHRcdFx0LnNldERlc2MoJ1BhdGggZm9yIHRoZSBydWxlLiBVc2UgXCJcIiBmb3IgYWxsIGZpbGVzLCBcIi9cIiBmb3Igcm9vdCBmb2xkZXIsIG9yIFwiRm9sZGVyTmFtZS9cIiBmb3Igc3BlY2lmaWMgZm9sZGVycyAoZW5zdXJlIHRyYWlsaW5nIHNsYXNoIGZvciBub24tcm9vdCBmb2xkZXJzKS4nKVxuXHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0XHR0ZXh0LnNldFBsYWNlaG9sZGVyKCdlLmcuLCBNZWV0aW5ncy8sIC8sIG9yIGVtcHR5IGZvciBhbGwnKVxuXHRcdFx0XHRcdFx0LnNldFZhbHVlKHJ1bGUucGF0aCB8fCAnJylcblx0XHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdFx0cnVsZS5wYXRoID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLm5vcm1hbGl6ZVJ1bGUocnVsZSk7IC8vIE5vcm1hbGl6ZSBwYXRoIGFuZCByZWN1cnNpdmUgZmxhZ1xuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5kaXNwbGF5KCk7IC8vIFJlLXJlbmRlciB0byB1cGRhdGUgcmVjdXJzaXZlIHRvZ2dsZSBzdGF0ZSBpZiBuZWVkZWRcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdC8vIEF0dGFjaCBzdWdnZXN0aW9uIHByb3ZpZGVyIGZvciBmb2xkZXIgcGF0aHNcblx0XHRcdFx0XHRuZXcgTXVsdGlTdWdnZXN0KHRleHQuaW5wdXRFbCwgdGhpcy5nZXRBdmFpbGFibGVGb2xkZXJQYXRocygpLCAoc2VsZWN0ZWRQYXRoKSA9PiB7XG5cdFx0XHRcdFx0XHRydWxlLnBhdGggPSBzZWxlY3RlZFBhdGg7XG5cdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5ub3JtYWxpemVSdWxlKHJ1bGUpO1xuXHRcdFx0XHRcdFx0dGV4dC5zZXRWYWx1ZShzZWxlY3RlZFBhdGgpOyAvLyBVcGRhdGUgdGV4dCBmaWVsZCB3aXRoIHNlbGVjdGlvblxuXHRcdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCkudGhlbigoKSA9PiB0aGlzLmRpc3BsYXkoKSk7XG5cdFx0XHRcdFx0fSwgdGhpcy5wbHVnaW4uYXBwKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdG5ldyBTZXR0aW5nKHJ1bGVDb250ZW50Q29udGFpbmVyKVxuXHRcdFx0XHQuc2V0TmFtZSgnSW5jbHVkZSBzdWJmb2xkZXJzIChyZWN1cnNpdmUpJylcblx0XHRcdFx0LnNldERlc2MoJ0lmIGVuYWJsZWQsIHJ1bGUgYXBwbGllcyB0byBmaWxlcyBpbiBzdWJmb2xkZXJzLiBGb3IgXCJhbGwgZmlsZXNcIiAoZW1wdHkgcGF0aCksIHRoaXMgaXMgYWx3YXlzIHRydWUuIEZvciByb290IHBhdGggKFwiL1wiKSwgZW5hYmxpbmcgYXBwbGllcyB0byBhbGwgdmF1bHQgZmlsZXMsIGRpc2FibGluZyBhcHBsaWVzIG9ubHkgdG8gZmlsZXMgZGlyZWN0bHkgaW4gdGhlIHJvb3QuJylcblx0XHRcdFx0LmFkZFRvZ2dsZSh0b2dnbGUgPT4ge1xuXHRcdFx0XHRcdHRvZ2dsZS5zZXRWYWx1ZShydWxlLnJlY3Vyc2l2ZSEpIC8vIG5vcm1hbGl6ZVJ1bGUgZW5zdXJlcyAncmVjdXJzaXZlJyBpcyBib29sZWFuXG5cdFx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHJ1bGUucmVjdXJzaXZlID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Ly8gRGlzYWJsZSB0b2dnbGUgaWYgcGF0aCBpcyBcIlwiIChhbGwgZmlsZXMpLCBhcyByZWN1cnNpdmUgaXMgYWx3YXlzIHRydWVcblx0XHRcdFx0XHRpZiAocnVsZS5wYXRoID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHR0b2dnbGUuc2V0RGlzYWJsZWQodHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdH0gZWxzZSBpZiAocnVsZS50eXBlID09PSBSdWxlVHlwZS5UYWcpIHtcblx0XHRcdG5ldyBTZXR0aW5nKHJ1bGVDb250ZW50Q29udGFpbmVyKVxuXHRcdFx0XHQuc2V0TmFtZSgnVGFnIHZhbHVlJylcblx0XHRcdFx0LnNldERlc2MoJ1RhZyB0byBtYXRjaCAod2l0aG91dCB0aGUgIyBwcmVmaXgpLiBFLmcuLCBcInByb2plY3RcIiBvciBcInN0YXR1cy9kb25lXCIuJylcblx0XHRcdFx0LmFkZFRleHQodGV4dCA9PiB7XG5cdFx0XHRcdFx0dGV4dC5zZXRQbGFjZWhvbGRlcignZS5nLiwgaW1wb3J0YW50IG9yIHByb2plY3QvYWxwaGEnKVxuXHRcdFx0XHRcdFx0LnNldFZhbHVlKHJ1bGUudGFnIHx8ICcnKVxuXHRcdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHQvLyBFbnN1cmUgdGFnIGRvZXNuJ3Qgc3RhcnQgd2l0aCAnIydcblx0XHRcdFx0XHRcdFx0cnVsZS50YWcgPSB2YWx1ZS5zdGFydHNXaXRoKCcjJykgPyB2YWx1ZS5zdWJzdHJpbmcoMSkgOiB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRuZXcgTXVsdGlTdWdnZXN0KHRleHQuaW5wdXRFbCwgdGhpcy5nZXRBdmFpbGFibGVUYWdzKCksIChzZWxlY3RlZFRhZykgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3Qgbm9ybWFsaXplZFRhZyA9IHNlbGVjdGVkVGFnLnN0YXJ0c1dpdGgoJyMnKSA/IHNlbGVjdGVkVGFnLnN1YnN0cmluZygxKSA6IHNlbGVjdGVkVGFnO1xuXHRcdFx0XHRcdFx0cnVsZS50YWcgPSBub3JtYWxpemVkVGFnO1xuXHRcdFx0XHRcdFx0dGV4dC5zZXRWYWx1ZShub3JtYWxpemVkVGFnKTtcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdH0sIHRoaXMucGx1Z2luLmFwcCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRuZXcgU2V0dGluZyhydWxlQ29udGVudENvbnRhaW5lcilcblx0XHRcdFx0LnNldE5hbWUoJ0luY2x1ZGUgc3VidGFncycpXG5cdFx0XHRcdC5zZXREZXNjKFwiSWYgZW5hYmxlZCwgYSBydWxlIGZvciAndGFnJyB3aWxsIGFsc28gYXBwbHkgdG8gJ3RhZy9zdWJ0YWcxJywgJ3RhZy9zdWJ0YWcyL3N1YnRhZzMnLCBldGMuIElmIGRpc2FibGVkLCBpdCBvbmx5IGFwcGxpZXMgdG8gdGhlIGV4YWN0IHRhZy5cIilcblx0XHRcdFx0LmFkZFRvZ2dsZSh0b2dnbGUgPT4ge1xuXHRcdFx0XHRcdHRvZ2dsZS5zZXRWYWx1ZShydWxlLmluY2x1ZGVTdWJ0YWdzISkgLy8gbm9ybWFsaXplUnVsZSBlbnN1cmVzICdpbmNsdWRlU3VidGFncycgaXMgYm9vbGVhblxuXHRcdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRydWxlLmluY2x1ZGVTdWJ0YWdzID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAocnVsZS50eXBlID09PSBSdWxlVHlwZS5Qcm9wZXJ0eSkge1xuXHRcdFx0bmV3IFNldHRpbmcocnVsZUNvbnRlbnRDb250YWluZXIpXG5cdFx0XHRcdC5zZXROYW1lKCdQcm9wZXJ0eSBuYW1lJylcblx0XHRcdFx0LnNldERlc2MoJ1RoZSBuYW1lIG9mIHRoZSBPYnNpZGlhbiBwcm9wZXJ0eSAoZnJvbnRtYXR0ZXIga2V5KSB0byBtYXRjaC4nKVxuXHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0XHR0ZXh0LnNldFBsYWNlaG9sZGVyKCdlLmcuLCBzdGF0dXMsIHR5cGUsIGF1dGhvcicpXG5cdFx0XHRcdFx0XHQuc2V0VmFsdWUocnVsZS5wcm9wZXJ0eU5hbWUgfHwgJycpXG5cdFx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHJ1bGUucHJvcGVydHlOYW1lID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0bmV3IE11bHRpU3VnZ2VzdCh0ZXh0LmlucHV0RWwsIHRoaXMuZ2V0QXZhaWxhYmxlUHJvcGVydHlOYW1lcygpLCAoc2VsZWN0ZWROYW1lKSA9PiB7XG5cdFx0XHRcdFx0XHRydWxlLnByb3BlcnR5TmFtZSA9IHNlbGVjdGVkTmFtZTtcblx0XHRcdFx0XHRcdHRleHQuc2V0VmFsdWUoc2VsZWN0ZWROYW1lKTtcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdH0sIHRoaXMucGx1Z2luLmFwcCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRuZXcgU2V0dGluZyhydWxlQ29udGVudENvbnRhaW5lcilcblx0XHRcdFx0LnNldE5hbWUoJ1Byb3BlcnR5IHZhbHVlJylcblx0XHRcdFx0LnNldERlc2MoJ1RoZSB2YWx1ZSB0aGUgcHJvcGVydHkgc2hvdWxkIGhhdmUuIEZvciBsaXN0L2FycmF5IHByb3BlcnRpZXMsIG1hdGNoZXMgaWYgdGhpcyB2YWx1ZSBpcyBvbmUgb2YgdGhlIGl0ZW1zLicpXG5cdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignZS5nLiwgY29tcGxldGUsIGFydGljbGUsIEpvaG4gRG9lJylcblx0XHRcdFx0XHQuc2V0VmFsdWUocnVsZS5wcm9wZXJ0eVZhbHVlIHx8ICcnKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHJ1bGUucHJvcGVydHlWYWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0fSkpO1xuXHRcdH1cblxuXHRcdC8vIC0tLSBDb250ZW50IFNvdXJjZSBTZXR0aW5ncyAtLS1cblx0XHRuZXcgU2V0dGluZyhydWxlQ29udGVudENvbnRhaW5lcilcblx0XHRcdC5zZXROYW1lKCdDb250ZW50IHNvdXJjZScpXG5cdFx0XHQuc2V0RGVzYygnV2hlcmUgdG8gZ2V0IHRoZSBjb250ZW50IGZyb206IGRpcmVjdCB0ZXh0IGlucHV0IG9yIGEgc2VwYXJhdGUgTWFya2Rvd24gZmlsZS4nKVxuXHRcdFx0LmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IGRyb3Bkb3duXG5cdFx0XHRcdC5hZGRPcHRpb24oQ29udGVudFNvdXJjZS5UZXh0LCAnRGlyZWN0IHRleHQnKVxuXHRcdFx0XHQuYWRkT3B0aW9uKENvbnRlbnRTb3VyY2UuRmlsZSwgJ01hcmtkb3duIGZpbGUnKVxuXHRcdFx0XHQuc2V0VmFsdWUocnVsZS5jb250ZW50U291cmNlIHx8IENvbnRlbnRTb3VyY2UuVGV4dCkgLy8gRGVmYXVsdCB0byBUZXh0IGlmIHVuZGVmaW5lZFxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBzdHJpbmcpID0+IHtcblx0XHRcdFx0XHRydWxlLmNvbnRlbnRTb3VyY2UgPSB2YWx1ZSBhcyBDb250ZW50U291cmNlO1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLm5vcm1hbGl6ZVJ1bGUocnVsZSk7IC8vIE5vcm1hbGl6ZSBmb3IgY29udGVudCBzb3VyY2Ugc3BlY2lmaWMgZmllbGRzXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0dGhpcy5kaXNwbGF5KCk7IC8vIFJlLXJlbmRlciB0byBzaG93L2hpZGUgY29udGVudCBzb3VyY2Ugc3BlY2lmaWMgZmllbGRzXG5cdFx0XHRcdH0pKTtcblxuXHRcdGlmIChydWxlLmNvbnRlbnRTb3VyY2UgPT09IENvbnRlbnRTb3VyY2UuRmlsZSkge1xuXHRcdFx0bmV3IFNldHRpbmcocnVsZUNvbnRlbnRDb250YWluZXIpXG5cdFx0XHRcdC5zZXROYW1lKCdDb250ZW50IGZpbGUgcGF0aCcpXG5cdFx0XHRcdC5zZXREZXNjKCdQYXRoIHRvIHRoZSAubWQgZmlsZSB0byB1c2UgYXMgY29udGVudCAoZS5nLiwgXCJ0ZW1wbGF0ZXMvY29tbW9uLWZvb3Rlci5tZFwiKS4nKVxuXHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0XHR0ZXh0LnNldFBsYWNlaG9sZGVyKCdlLmcuLCB0ZW1wbGF0ZXMvY29tbW9uLWZvb3Rlci5tZCcpXG5cdFx0XHRcdFx0XHQuc2V0VmFsdWUocnVsZS5mb290ZXJGaWxlUGF0aCB8fCAnJykgLy8gUmV0YWluZWQgbmFtZSBmb3IgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRydWxlLmZvb3RlckZpbGVQYXRoID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0bmV3IE11bHRpU3VnZ2VzdCh0ZXh0LmlucHV0RWwsIHRoaXMuZ2V0QXZhaWxhYmxlTWFya2Rvd25GaWxlUGF0aHMoKSwgKHNlbGVjdGVkUGF0aCkgPT4ge1xuXHRcdFx0XHRcdFx0cnVsZS5mb290ZXJGaWxlUGF0aCA9IHNlbGVjdGVkUGF0aDtcblx0XHRcdFx0XHRcdHRleHQuc2V0VmFsdWUoc2VsZWN0ZWRQYXRoKTtcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdH0sIHRoaXMucGx1Z2luLmFwcCk7XG5cdFx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7IC8vIENvbnRlbnRTb3VyY2UuVGV4dFxuXHRcdFx0bmV3IFNldHRpbmcocnVsZUNvbnRlbnRDb250YWluZXIpXG5cdFx0XHRcdC5zZXROYW1lKCdDb250ZW50IHRleHQnKVxuXHRcdFx0XHQuc2V0RGVzYygnTWFya2Rvd24gdGV4dCB0byBkaXNwbGF5LiBUaGlzIHdpbGwgYmUgcmVuZGVyZWQuJylcblx0XHRcdFx0LmFkZFRleHRBcmVhKHRleHQgPT4gdGV4dFxuXHRcdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRW50ZXIgeW91ciBtYXJrZG93biBjb250ZW50IGhlcmUuLi5cXG5TdXBwb3J0cyBtdWx0aXBsZSBsaW5lcyBhbmQgKipNYXJrZG93bioqIGZvcm1hdHRpbmcuJylcblx0XHRcdFx0XHQuc2V0VmFsdWUocnVsZS5mb290ZXJUZXh0IHx8ICcnKSAvLyBSZXRhaW5lZCBuYW1lIGZvciBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0cnVsZS5mb290ZXJUZXh0ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHR9KSk7XG5cdFx0fVxuXG5cdFx0Ly8gLS0tIFJlbmRlciBMb2NhdGlvbiBTZXR0aW5nIC0tLVxuXHRcdG5ldyBTZXR0aW5nKHJ1bGVDb250ZW50Q29udGFpbmVyKVxuXHRcdFx0LnNldE5hbWUoJ1JlbmRlciBsb2NhdGlvbicpXG5cdFx0XHQuc2V0RGVzYygnQ2hvb3NlIHdoZXRoZXIgdGhpcyBydWxlIHJlbmRlcnMgaXRzIGNvbnRlbnQgaW4gdGhlIGhlYWRlciBvciBmb290ZXIgb2YgdGhlIG5vdGUuJylcblx0XHRcdC5hZGREcm9wZG93bihkcm9wZG93biA9PiBkcm9wZG93blxuXHRcdFx0XHQuYWRkT3B0aW9uKFJlbmRlckxvY2F0aW9uLkZvb3RlciwgJ0Zvb3RlcicpXG5cdFx0XHRcdC5hZGRPcHRpb24oUmVuZGVyTG9jYXRpb24uSGVhZGVyLCAnSGVhZGVyJylcblx0XHRcdFx0LnNldFZhbHVlKHJ1bGUucmVuZGVyTG9jYXRpb24gfHwgUmVuZGVyTG9jYXRpb24uRm9vdGVyKSAvLyBEZWZhdWx0IHRvIEZvb3RlclxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBzdHJpbmcpID0+IHtcblx0XHRcdFx0XHRydWxlLnJlbmRlckxvY2F0aW9uID0gdmFsdWUgYXMgUmVuZGVyTG9jYXRpb247XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdH0pKTtcblx0XHRcblx0XHQvLyAtLS0gUnVsZSBBY3Rpb25zOiBSZW9yZGVyIGFuZCBEZWxldGUgLS0tXG5cdFx0Y29uc3QgcnVsZUFjdGlvbnNTZXR0aW5nID0gbmV3IFNldHRpbmcocnVsZUNvbnRlbnRDb250YWluZXIpXG5cdFx0XHQuc2V0Q2xhc3MoJ3ZpcnR1YWwtZm9vdGVyLXJ1bGUtYWN0aW9ucycpO1xuXG5cdFx0Ly8gTW92ZSBVcCBCdXR0b25cblx0XHRydWxlQWN0aW9uc1NldHRpbmcuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cblx0XHRcdC5zZXRJY29uKCdhcnJvdy11cCcpXG5cdFx0XHQuc2V0VG9vbHRpcCgnTW92ZSBydWxlIHVwJylcblx0XHRcdC5zZXRDbGFzcygndmlydHVhbC1mb290ZXItbW92ZS1idXR0b24nKVxuXHRcdFx0LnNldERpc2FibGVkKGluZGV4ID09PSAwKVxuXHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRpZiAoaW5kZXggPiAwKSB7XG5cdFx0XHRcdFx0Y29uc3QgcnVsZXMgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5ydWxlcztcblx0XHRcdFx0XHRjb25zdCBydWxlVG9Nb3ZlID0gcnVsZXMuc3BsaWNlKGluZGV4LCAxKVswXTtcblx0XHRcdFx0XHRydWxlcy5zcGxpY2UoaW5kZXggLSAxLCAwLCBydWxlVG9Nb3ZlKTtcblxuXHRcdFx0XHRcdGNvbnN0IGV4cGFuZGVkU3RhdGVUb01vdmUgPSB0aGlzLnJ1bGVFeHBhbmRlZFN0YXRlcy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuXHRcdFx0XHRcdHRoaXMucnVsZUV4cGFuZGVkU3RhdGVzLnNwbGljZShpbmRleCAtIDEsIDAsIGV4cGFuZGVkU3RhdGVUb01vdmUpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdHRoaXMuZGlzcGxheSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KSk7XG5cblx0XHQvLyBNb3ZlIERvd24gQnV0dG9uXG5cdFx0cnVsZUFjdGlvbnNTZXR0aW5nLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG5cdFx0XHQuc2V0SWNvbignYXJyb3ctZG93bicpXG5cdFx0XHQuc2V0VG9vbHRpcCgnTW92ZSBydWxlIGRvd24nKVxuXHRcdFx0LnNldENsYXNzKCd2aXJ0dWFsLWZvb3Rlci1tb3ZlLWJ1dHRvbicpXG5cdFx0XHQuc2V0RGlzYWJsZWQoaW5kZXggPT09IHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bGVzLmxlbmd0aCAtIDEpXG5cdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGlmIChpbmRleCA8IHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bGVzLmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0XHRjb25zdCBydWxlcyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bGVzO1xuXHRcdFx0XHRcdGNvbnN0IHJ1bGVUb01vdmUgPSBydWxlcy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuXHRcdFx0XHRcdHJ1bGVzLnNwbGljZShpbmRleCArIDEsIDAsIHJ1bGVUb01vdmUpO1xuXG5cdFx0XHRcdFx0Y29uc3QgZXhwYW5kZWRTdGF0ZVRvTW92ZSA9IHRoaXMucnVsZUV4cGFuZGVkU3RhdGVzLnNwbGljZShpbmRleCwgMSlbMF07XG5cdFx0XHRcdFx0dGhpcy5ydWxlRXhwYW5kZWRTdGF0ZXMuc3BsaWNlKGluZGV4ICsgMSwgMCwgZXhwYW5kZWRTdGF0ZVRvTW92ZSk7XG5cblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHR0aGlzLmRpc3BsYXkoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSkpO1xuXHRcdFxuXHRcdC8vIFNwYWNlciB0byBwdXNoIGRlbGV0ZSBidXR0b24gdG8gdGhlIHJpZ2h0XG5cdFx0cnVsZUFjdGlvbnNTZXR0aW5nLmNvbnRyb2xFbC5jcmVhdGVEaXYoeyBjbHM6ICd2aXJ0dWFsLWZvb3Rlci1hY3Rpb25zLXNwYWNlcicgfSk7XG5cblxuXHRcdC8vIERlbGV0ZSBSdWxlIEJ1dHRvblxuXHRcdHJ1bGVBY3Rpb25zU2V0dGluZy5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuXHRcdFx0LnNldEJ1dHRvblRleHQoJ0RlbGV0ZSBydWxlJylcblx0XHRcdC5zZXRXYXJuaW5nKCkgLy8gU3R5bGUgYXMgYSB3YXJuaW5nL2Rlc3RydWN0aXZlIGFjdGlvblxuXHRcdFx0LnNldENsYXNzKCd2aXJ0dWFsLWZvb3Rlci1kZWxldGUtYnV0dG9uJylcblx0XHRcdC5vbkNsaWNrKGFzeW5jICgpID0+IHtcblx0XHRcdFx0Ly8gQ29uZmlybWF0aW9uIGNvdWxkIGJlIGFkZGVkIGhlcmUgaWYgZGVzaXJlZFxuXHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5ydWxlcy5zcGxpY2UoaW5kZXgsIDEpOyAvLyBSZW1vdmUgcnVsZSBmcm9tIGFycmF5XG5cdFx0XHRcdHRoaXMucnVsZUV4cGFuZGVkU3RhdGVzLnNwbGljZShpbmRleCwgMSk7IC8vIFJlbW92ZSBjb3JyZXNwb25kaW5nIHN0YXRlXG5cdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHR0aGlzLmRpc3BsYXkoKTsgLy8gUmUtcmVuZGVyIHRvIHJlZmxlY3QgZGVsZXRpb24gYW5kIHVwZGF0ZSBpbmRpY2VzXG5cdFx0XHR9KSk7XG5cdH1cbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQVdPO0FBS1AsSUFBSyxXQUFMLGtCQUFLQSxjQUFMO0FBQ0MsRUFBQUEsVUFBQSxZQUFTO0FBQ1QsRUFBQUEsVUFBQSxTQUFNO0FBQ04sRUFBQUEsVUFBQSxjQUFXO0FBSFAsU0FBQUE7QUFBQSxHQUFBO0FBT0wsSUFBSyxnQkFBTCxrQkFBS0MsbUJBQUw7QUFDQyxFQUFBQSxlQUFBLFVBQU87QUFDUCxFQUFBQSxlQUFBLFVBQU87QUFGSCxTQUFBQTtBQUFBLEdBQUE7QUFxRUwsSUFBTSxtQkFBMEM7QUFBQSxFQUMvQyxPQUFPLENBQUM7QUFBQSxJQUNQLE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxJQUNULE1BQU07QUFBQSxJQUNOLE1BQU07QUFBQTtBQUFBLElBQ04sV0FBVztBQUFBLElBQ1gsZUFBZTtBQUFBLElBQ2YsWUFBWTtBQUFBO0FBQUEsSUFDWixnQkFBZ0I7QUFBQSxFQUNqQixDQUFDO0FBQUEsRUFDRCxtQkFBbUI7QUFBQTtBQUNwQjtBQUdBLElBQU0sOEJBQThCO0FBQ3BDLElBQU0sMkJBQTJCO0FBQ2pDLElBQU0sMkJBQTJCO0FBQ2pDLElBQU0sOEJBQThCO0FBQ3BDLElBQU0sOEJBQThCO0FBQ3BDLElBQU0sZ0NBQWdDO0FBQ3RDLElBQU0saUNBQWlDO0FBR3ZDLElBQU0sK0JBQStCO0FBQ3JDLElBQU0sMkNBQTJDO0FBQ2pELElBQU0sMENBQTBDO0FBQ2hELElBQU0sd0JBQXdCO0FBQzlCLElBQU0sK0JBQStCO0FBQ3JDLElBQU0sK0JBQStCO0FBTzlCLElBQU0s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
